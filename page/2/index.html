<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-垃圾收集算法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/12/垃圾收集算法/" class="article-date">
  <time datetime="2015-06-11T16:00:00.000Z" itemprop="datePublished">2015-06-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/12/垃圾收集算法/">垃圾收集算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p>
<p>不足之处：</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/2455482-b9efd3da3114ad6c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记清除.jpeg"></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p>
<p>不足之处：<br>这种算法的代价是把内存缩小为原来的一半，代价太高了</p>
<p>但是现在的商业虚拟机都采用这种收集算法来回收新生代。<br><code>IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</code><br>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保（HandlePromotion）</strong><a href="内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。">^1</a>。<br><img src="https://upload-images.jianshu.io/upload_images/2455482-8193b954387d1811.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="复制.jpeg"></p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图<img src="https://upload-images.jianshu.io/upload_images/2455482-ae3d0119f93479e9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标记整理.jpeg"></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。<strong>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/06/12/垃圾收集算法/" data-id="cjr95435v0006gfww56hkacri" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java虚拟机中对象生存还是死亡" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/06/java虚拟机中对象生存还是死亡/" class="article-date">
  <time datetime="2015-05-05T16:00:00.000Z" itemprop="datePublished">2015-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/06/java虚拟机中对象生存还是死亡/">对象是生存还是死亡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java堆里存着几乎所有的对象，垃圾收集器要判断，哪些对象是存活的，哪些是死亡的（没有被引用的对象）即需要被回收的。</p>
<h2 id="判断对象是否存活有两种算法"><a href="#判断对象是否存活有两种算法" class="headerlink" title="判断对象是否存活有两种算法"></a>判断对象是否存活有两种算法</h2><ol>
<li><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。例如微软公司的COM（ComponentObjectModel）技术、使用ActionScript3的FlashPlayer、Python语言和在游戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。<strong>但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</strong>以下是互相引用的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefrenceCounterGC</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    RefresnceCounterGC a = <span class="keyword">new</span> RefrenceCounterGC();</span><br><span class="line">    RefresnceCounterGC b = <span class="keyword">new</span> RefrenceCounterGC();</span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line">    a=<span class="keyword">null</span>;</span><br><span class="line">    b=<span class="keyword">null</span>;</span><br><span class="line">    System.gc();<span class="comment">// a/b指向的对象被回收了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a b引用指向的对象，仍然被相互引用，但是最后仍然被垃圾收集器回收了</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>这个算法的基本思路就是通过一系列的称为”GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（ReferenceChain），当一个对象到GCRoots没有任何引用链相连（用图论的话来说，就是从GCRoots到这个对象不可达）时，则证明此对象是不可用的。<img src="https://upload-images.jianshu.io/upload_images/2455482-3b35435258d53c33.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="可达性算法.jpeg"><br>在Java语言中，可作为GCRoots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。<h2 id="引用概念"><a href="#引用概念" class="headerlink" title="引用概念"></a>引用概念</h2>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。</li>
</ul>
</li>
</ol>
<ul>
<li>JDK1.2以前，Java中的引用的定义很传统一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。</li>
<li>在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次逐渐减弱。<ul>
<li>强引用（StrongReference）<br>就是指在程序代码之中普遍存在的，类似”Objectobj=newObject()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用（SoftReference）<br>用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用（WeakReference）<br>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用（PhantomReference）<br>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：<strong>如果对象在进行可达性分析后发现没有与GCRoots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</strong></li>
</ul>
</li>
</ul>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</strong>从下列代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes i am still alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize executed"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//进入gc 调用finalize 实现自救</span></span><br><span class="line">        System.gc();</span><br><span class="line">      <span class="comment">// 因为finalize 优先级很低所以等待0.5秒        </span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"I'm dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//下面这段代码与上面的完全相同,但是这次自救却失败了</span></span><br><span class="line">        <span class="comment">//这是因为任何一个对象的finalize()方法都只会被系统自动调用一次</span></span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"I'm dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize executed</span><br><span class="line">yes i am still alive</span><br><span class="line">I&apos;m dead</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/06/java虚拟机中对象生存还是死亡/" data-id="cjr95435s0004gfww8ipyaast" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java虚拟中对象的定位" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/21/java虚拟中对象的定位/" class="article-date">
  <time datetime="2015-04-20T16:00:00.000Z" itemprop="datePublished">2015-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/21/java虚拟中对象的定位/">java虚拟机中对象的定位</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>建立对象是为了使用对象，我们的程序通过栈上的refrence引用来操作堆里的具体对象。由于refrence类型在java虚拟机规范中只规定了一个指向对象的应用，并没有定义这个引用通过何种方式去定位、访问堆内对象的具体位置，所以对象访问方式也是取决与虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种</p>
<ul>
<li>句柄访问<br>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<img src="https://upload-images.jianshu.io/upload_images/2455482-61526b8bfda3d13a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="句柄.jpeg"></li>
</ul>
<p><code>好处：使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</code></p>
<ul>
<li>直接指针<br>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。<img src="https://upload-images.jianshu.io/upload_images/2455482-2a53e6f1468970e9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直接指针.jpeg"></li>
</ul>
<p><code>好处：使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机SunHotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</code></p>
<p>相关文章:<br><a href="https://www.jianshu.com/p/282777946dad" target="_blank" rel="noopener">java虚拟机中对象的创建</a><br><a href="https://www.jianshu.com/p/cc3f193db928" target="_blank" rel="noopener">java虚拟机中对象的内存布局</a><br><a href="https://www.jianshu.com/p/762f97391cac" target="_blank" rel="noopener">java虚拟机中对象的定位</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/21/java虚拟中对象的定位/" data-id="cjr95435u0005gfww3pwfvrth" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java虚拟机中对象的内存布局" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/03/java虚拟机中对象的内存布局/" class="article-date">
  <time datetime="2015-04-02T16:00:00.000Z" itemprop="datePublished">2015-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/03/java虚拟机中对象的内存布局/">java虚拟机中对象的内存布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在HotSpot虚拟机中，对象的内存布局分为三块区域：对象头(Object Header)、实例数据(Instance Data)、对齐填充(Padding)。</p>
<ul>
<li>对象头（Object Header）<ul>
<li>存储对象自身的运行时数据：如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等<br><code>这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为&quot;MarkWord&quot;。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，MarkWord被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么MarkWord的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表2-1。</code></li>
<li>类型指针(即对象指向它的类元数据的指针)：虚拟机通过这个指针来确定这个对象是哪个类的实例。(注：并不是所有虚拟机的实现都必须在对象数据里保存类型指针，换句话说，查找对象的类的元数据信息不一定要通过对象本身)另外如果对象是一个数组，那么在对象头中还必须有一块来记录数据的长度，因为虚拟机可以根据普通对象的元数据信息来确定对象的大小，但是从数组的元数据里无法确定数组的大小。</li>
</ul>
</li>
<li>实例数据 (instance Data)<br>对象真正存储的有效信息，也是在程序代码中定义的各种类型的字段内容。无论是父类继承的还是子类中定义的，都需要记录起来。<br><code>这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObjectPointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</code></li>
<li>对齐填充(Padding)<br>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。<br><code>由于HotSpotVM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</code></li>
</ul>
<p>相关文章：<br><a href="https://www.jianshu.com/p/282777946dad" target="_blank" rel="noopener">java虚拟机中对象的创建</a><br><a href="https://www.jianshu.com/p/cc3f193db928" target="_blank" rel="noopener">java虚拟机中对象的内存布局</a><br><a href="https://www.jianshu.com/p/762f97391cac" target="_blank" rel="noopener">java虚拟机中对象的定位</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/03/java虚拟机中对象的内存布局/" data-id="cjr95435o0001gfwwtr9xbfv1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java虚拟机中对象的创建" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/03/java虚拟机中对象的创建/" class="article-date">
  <time datetime="2015-02-02T16:00:00.000Z" itemprop="datePublished">2015-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/03/java虚拟机中对象的创建/">java虚拟机中对象的创建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> &emsp;&emsp;我们了解虚拟机内存划分的人，都知道对象的内存分配几乎都是在堆上的，这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都会在堆上分配（但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些变化，擦扯远了，所以所有的对象实例都在堆上分配就不是那么绝对了）</p>
<p>下面说虚拟机中对象的创建几个步骤</p>
<ol>
<li>类加载检查<br>&emsp;&emsp;虚拟机遇到new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被装载、解析和初始化过。如果没有那必须先执行相应的类的加载过程。</li>
<li>为对象分配内存<br>&emsp;&emsp;当类加载成功后，类的对象的大小是确定了的。对象内存的划分等同于在堆里划分出一块指定大小的内存。<br>&emsp;&emsp;假设内存是规整的，所有用过的内存放在一边，空闲的放在另一边，中间分界点有个指针，那分配内存就是把指针向空闲区域方向挪动一段于对象大小相等的长度，这种分配方式叫做“指针碰撞”(Bump the Pointer)。<br>&emsp;&emsp;如果内存不是规整的，那么就需要一个表来记录，记录哪些内存是占用的，哪些是空闲的，那分配内存就是在表里找到一块足够大的空间分配给对象实例，并更新这个表的记录，这种分配方式叫做“空闲列表”(Free List)。<br>&emsp;&emsp;选择哪种分配方式与堆是否规整决定，而java堆是否规整又和垃圾收集器是否有压缩整理功能决定。因此，在使用Serial、ParNew等带有Compact过程的收集器时，采用的分配方式是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，采用的是空闲列表。<br>&emsp;&emsp;除了如何划分内存之外还有一个是我们需要考虑的问题，因为java堆是线程共享的，那么多个线程同时操作堆上的内存就会有问题，比如正在给a对象分配内存还没来得及移动指针(或者是没有修改空闲列表的记录)，这时对象b使用原来的指针来分配内存，就会产生问题。解决这个问题有两种方式，一种是对分配内存的动作进行同步处理(实际上虚拟机采用CAS配上错误重试来保证分配内存的原子性)；另一种是采用线程间不共享的内存来分配，每个线程预先在java堆中分配一块内存，成为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB )。哪个线程分配内存就在该线程的TLAB上分配，只有在TLAB用完需要分配新的TLAB时，才需要同步锁定。注：虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</li>
<li>内存初始化<br>&emsp;&emsp;内存分配完后，需要把将分配到的内存空间初始化为零值(不包换对象头)，如果使用TLAB这一过程也可以提前至TLAB分配时进行。这一步操作保证了对象实例字段在java代码中可以不赋初值就使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>对象头必要设置<br>&emsp;&emsp;接下来虚拟机要对对象进行必要的设置，比如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的hash码、对象的gc分代年龄等信息。这些信息均放在对象的对象头(Object Header)中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置</li>
</ol>
<p>总结<br>以上步骤完成后，从虚拟机的角度来看，一个新对象诞生了，但从java程序角度看，一切才刚刚开始——init方法还没有执行，所有字段的数据类型都是对应的零值。所以一般来说执行new指令后会接着执行init方法，把对象按照程序猿的意愿进行初始化，这样一个真正可以使用的对象才算完成。</p>
<p>下面的代码是HotPot虚拟机bytecodeInterpreter.cpp的代码片段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">u2 index = Bytes::get_Java_u2(pc+<span class="number">1</span>);</span><br><span class="line">ConstantPool* constants = istate-&gt;method()-&gt;constants();</span><br><span class="line"><span class="comment">// 确保常量池中是已经解释的类</span></span><br><span class="line"><span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123;</span><br><span class="line">  <span class="comment">// Make sure klass is initialized and doesn't have a finalizer</span></span><br><span class="line">  <span class="comment">// 确保类已经初始化</span></span><br><span class="line">  Klass* entry = constants-&gt;slot_at(index).get_klass();</span><br><span class="line">  assert(entry-&gt;is_klass(), <span class="string">"Should be resolved klass"</span>);</span><br><span class="line">  Klass* k_entry = (Klass*) entry;</span><br><span class="line">  assert(k_entry-&gt;oop_is_instance(), <span class="string">"Should be InstanceKlass"</span>);</span><br><span class="line">  InstanceKlass* ik = (InstanceKlass*) k_entry;</span><br><span class="line">  <span class="comment">// 确保对象内存已经初始化</span></span><br><span class="line">  <span class="keyword">if</span> ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123;</span><br><span class="line">    <span class="comment">// 取对象长度</span></span><br><span class="line">    <span class="keyword">size_t</span> obj_size = ik-&gt;size_helper();</span><br><span class="line">    oop result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// If the TLAB isn't pre-zeroed then we'll have to do it</span></span><br><span class="line">    <span class="comment">// 如果TLAB没有预先初始化那么need_zero为true后边会进行初始化</span></span><br><span class="line">    <span class="keyword">bool</span> need_zero = !ZeroTLAB;</span><br><span class="line">    <span class="comment">// 如果虚拟机启用TLAB，那么在TLAB中分配对象</span></span><br><span class="line">    <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">      result = (oop) THREAD-&gt;tlab().allocate(obj_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      need_zero = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// Try allocate in shared eden</span></span><br><span class="line">      <span class="comment">// 尝试在eden中分配对象</span></span><br><span class="line">retry:</span><br><span class="line">      HeapWord* compare_to = *Universe::heap()-&gt;top_addr();</span><br><span class="line">      HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">      <span class="comment">/*cmpxchg是x86中的CAS指令，这里是一个C++方法通过CAS方式分配空间，如果并发失败，转到retry中重试直至成功分配为止*/</span></span><br><span class="line">      <span class="keyword">if</span> (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123;</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        result = (oop) compare_to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// Initialize object (if nonzero size and need) and then the header</span></span><br><span class="line">     <span class="comment">// 如果需要，则为对象初始化零值</span></span><br><span class="line">      <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">        HeapWord* to_zero = (HeapWord*) result + <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">        obj_size -= <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">        <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">          <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据是否启用偏向锁来设置对象头信息</span></span><br><span class="line">      <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">        result-&gt;set_mark(ik-&gt;prototype_header());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;set_mark(markOopDesc::prototype());</span><br><span class="line">      &#125;</span><br><span class="line">      result-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">      result-&gt;set_klass(k_entry);</span><br><span class="line">     <span class="comment">// 将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">      SET_STACK_OBJECT(result, <span class="number">0</span>);</span><br><span class="line">      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="https://www.jianshu.com/p/282777946dad" target="_blank" rel="noopener">java虚拟机中对象的创建</a><br><a href="https://www.jianshu.com/p/cc3f193db928" target="_blank" rel="noopener">java虚拟机中对象的内存布局</a><br><a href="https://www.jianshu.com/p/762f97391cac" target="_blank" rel="noopener">java虚拟机中对象的定位</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/03/java虚拟机中对象的创建/" data-id="cjr95435k0000gfwwa64r4aba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/jvm/" style="font-size: 20px;">jvm</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/23/hello/">hello</a>
          </li>
        
          <li>
            <a href="/2019/01/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/03/24/运行时栈帧结构/">运行时栈帧结构</a>
          </li>
        
          <li>
            <a href="/2017/09/21/类加载器/">类加载器</a>
          </li>
        
          <li>
            <a href="/2017/07/28/类加载过程/">类加载过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>