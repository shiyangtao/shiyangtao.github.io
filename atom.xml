<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shiyangtao&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shiyangtao.github.io/"/>
  <updated>2019-08-15T13:13:29.299Z</updated>
  <id>http://shiyangtao.github.io/</id>
  
  <author>
    <name>sytao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《趣谈网络协议》第3-7讲笔记</title>
    <link href="http://shiyangtao.github.io/2019/08/14/%E3%80%8A%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E3%80%8B%E7%AC%AC3-7%E8%AE%B2%E7%AC%94%E8%AE%B0/"/>
    <id>http://shiyangtao.github.io/2019/08/14/《趣谈网络协议》第3-7讲笔记/</id>
    <published>2019-08-14T07:00:10.000Z</published>
    <updated>2019-08-15T13:13:29.299Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ifconfig-和-ip-addr的区别"><a href="#ifconfig-和-ip-addr的区别" class="headerlink" title="ifconfig 和 ip addr的区别"></a>ifconfig 和 ip addr的区别</h3><p>这是有关net-tools 和 iproute2的故事，后续回答这个问题</p><h3 id="IP是什么"><a href="#IP是什么" class="headerlink" title="IP是什么"></a>IP是什么</h3><p>ip地址是一个网卡在网络世界的通信地址，相当于我们现实世界的地址。</p><h3 id="IPv6出现原因"><a href="#IPv6出现原因" class="headerlink" title="IPv6出现原因"></a>IPv6出现原因</h3><p>这个地址被分为四个部分，每个部分8个bit，所以一共32位，所以IP地址的数量很快就不够用了。当时设计IP地址时，哪里知道会有这么多计算机，因为不够用所以，就有了IPv6，这个有128位。</p><h3 id="IP分类"><a href="#IP分类" class="headerlink" title="IP分类"></a>IP分类</h3><p>本来 32 位的 IP 地址就不够，还被分成了 5 类。现在想想，当时分配地址的时候，真是太奢侈了。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190814200829762.png" alt="image-20190814200829762"></p><p>A/B/C类分网络号和主机号两部分</p><h3 id="IP-A-B-C-类包含的主机数量"><a href="#IP-A-B-C-类包含的主机数量" class="headerlink" title="IP A/B/C 类包含的主机数量"></a>IP A/B/C 类包含的主机数量</h3><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">IP地址范围</th><th style="text-align:center">最大主机数</th><th style="text-align:center">私有IP地址范围</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">0.0.0.0-127.255.255.255</td><td style="text-align:center">16,777,214</td><td style="text-align:center">10.0.0.0-10.255.255.255</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">128.0.0.0-191.255.255.255</td><td style="text-align:center">65534</td><td style="text-align:center">172.16.0.0-172.31.255.255</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">192.0.0.0-223.255.255.255</td><td style="text-align:center">254</td><td style="text-align:center">192.168.0.0-192.168.255.255</td></tr></tbody></table><p>C类主机数太少了只有254个，一般大网吧都满足不了。B类又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。为了解决C类主机数太少，B类主机数太多，出现了CIDR</p><h3 id="无类型域间选路（CIDR）"><a href="#无类型域间选路（CIDR）" class="headerlink" title="无类型域间选路（CIDR）"></a>无类型域间选路（CIDR）</h3><p>这种方式打破了原来设计的分类方案，将原来的ip地址一分为二，前边是<strong>网络号</strong>，后边是<strong>主机号</strong></p><p>从哪里分呢？你如果注意观察的话可以看到，10.100.122.2/24，这个 IP 地址中有一个斜杠，斜杠后面有个数字 24。这种地址表示形式，就是 CIDR。后面 24 的意思是，32 位中，前 24 位是网络号，后 8 位是主机号。</p><p>CIDR里有几个概念</p><p><strong>广播地址</strong>:    10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到</p><p><strong>子网掩码</strong>:     255.255.255.0</p><p><strong>子网掩码&amp;IP地址=网络号</strong>:    10.100.122.2&amp;255.255.255.0=10.100.122.0</p><p>CIDR 可以用来判断是不是本地人，网络号一样就是本地人</p><h3 id="公有IP和私有IP"><a href="#公有IP和私有IP" class="headerlink" title="公有IP和私有IP"></a>公有IP和私有IP</h3><p>平时我们看到的数据中心里，办公室、家里或学校的 IP 地址，一般都是私有 IP 地址段。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址段和我学校的可以是一样的。</p><p>公有 IP 地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的 IT 人员给你一个 IP 地址就行。但是假如你要做一个类似网易 163 这样的网站，就需要有公有 IP 地址，这样全世界的人才能访问。</p><p>表格中的 192.168.0.x 是最常用的私有 IP 地址。你家里有 Wi-Fi，对应就会有一个 IP 地址。一般你家里地上网设备不会超过 256 个，所以 /24 基本就够了。有时候我们也能见到 /16 的 CIDR，这两种是最常见的，也是最容易理解的。  </p><p>不需要将十进制转换为二进制 32 位，就能明显看出 192.168.0 是网络号，后面是主机号。而整个网络里面的第一个地址 192.168.0.1，往往就是你这个私有网络的出口地址。例如，你家里的电脑连接 Wi-Fi，Wi-Fi 路由器的地址就是 192.168.0.1，而 192.168.0.255 就是广播地址。一旦发送这个地址，整个 192.168.0 网络里面的所有机器都能收到。  但是也不总都是这样的情况。因此，其他情况往往就会很难理解，还容易出错。</p><h3 id="ip-addr-和ifconfig-查ip信息内容分析"><a href="#ip-addr-和ifconfig-查ip信息内容分析" class="headerlink" title="ip addr 和ifconfig 查ip信息内容分析"></a>ip addr 和ifconfig 查ip信息内容分析</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f816:3eff:fec7:7975/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>在 IP 地址的后面有个 scope，对于 eth0 这张网卡来讲，是 global，说明这张网卡是可以对外的，可以接收来自各个地方的包。对于 lo 来讲，是 host，说明这张网卡仅仅可以供本机相互通信。 lo 全称是loopback，又称环回接口，往往会被分配到 127.0.0.1 这个地址。这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。 </p><p> MAC 地址是一个很容易让人“误解”的地址。因为 MAC 地址号称全局唯一，不会有两个网卡有相同的 MAC 地址，而且网卡自生产出来，就带着这个地址。</p><p>很多人看到这里就会想，既然这样，整个互联网的通信，全部用 MAC 地址好了，只要知道了对方的 MAC 地址，就可以把信息传过去。  这样当然是不行的。 一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能。 而有门牌号码属性的 <strong>IP 地址，才是有远程定位功能的。</strong>  例如，你去杭州市网商路 599 号 B 楼 6 层找刘超，你在路上问路，可能被问的人不知道 B 楼是哪个，但是可以给你指网商路怎么去。但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道。</p><p><strong>MAC 地址是有一定定位功能的，只不过范围非常有限。</strong>你可以根据 IP 地址，找到杭州市网商路 599 号 B 楼 6 层，但是依然找不到我，你就可以靠吼了，大声喊身份证 XXXX 的是哪位？我听到了，我就会站起来说，是我啊。但是如果你在上海，到处喊身份证 XXXX 的是哪位，我不在现场，当然不会回答，因为我在杭州不在上海。  所以，MAC 地址的通信范围比较小，局限在一个子网里面。例如，从 192.168.0.2/24 访问 192.168.0.3/24 是可以用 MAC 地址的。一旦跨子网，即从 192.168.0.2/24 到 192.168.1.2/24，MAC 地址就不行了，需要 IP 地址起作用了。</p><p><strong>MAC 地址更像是身份证，是一个唯一的标识。</strong>它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。  </p><h4 id="网络设备的状态标识"><a href="#网络设备的状态标识" class="headerlink" title="网络设备的状态标识"></a>网络设备的状态标识</h4><p>解析完了 MAC 地址，我们再来看 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; 是干什么的？这个叫作net_device flags，网络设备的状态标识。  UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。</p><h4 id="mtu"><a href="#mtu" class="headerlink" title="mtu"></a>mtu</h4><p>MTU1500 是指什么意思呢？是哪一层的概念呢？最大传输单元 MTU 为 1500，这是以太网的默认值。网络包是层层封装的。MTU 是二层 MAC 层的概念。MAC 层有 MAC 的头，以太网规定连 MAC 头带正文合起来，不允许超过 1500 个字节。正文里面有 IP 的头、TCP 的头、HTTP 的头。如果放不下，就需要分片来传输。</p><h4 id="qdisc"><a href="#qdisc" class="headerlink" title="qdisc"></a>qdisc</h4><p>qdisc pfifo_fast 是什么意思呢？qdisc 全称是queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。  </p><p>最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。</p><p>pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。  三个波段（band）的优先级也不相同。band 0 的优先级最高，band 2 的最低。如果 band 0 里面有数据包，系统就不会处理 band 1 里面的数据包，band 1 和 band 2 之间也是一样。  数据包是按照服务类型（Type of Service，TOS）被分配到三个波段（band）里面的。TOS 是 IP 头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。  队列是个好东西，后面我们讲云计算中的网络的时候，会有很多用户共享一个网络出口的情况，这个时候如何排队，每个队列有多粗，队列处理速度应该怎么提升，我都会详细为你讲解。</p><h3 id="如何手动设计IP地址"><a href="#如何手动设计IP地址" class="headerlink" title="如何手动设计IP地址"></a>如何手动设计IP地址</h3><p>使用net-tools:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo ifconfig eth1 10.0.0.1/24</span><br><span class="line"><span class="meta">$</span> sudo ifconfig eth1 up</span><br></pre></td></tr></table></figure><p>使用iproute2:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo ip addr add 10.0.0.1/24 dev eth1</span><br><span class="line"><span class="meta">$</span> sudo ip link set up eth1</span><br></pre></td></tr></table></figure><h3 id="如果身边的人的IP都是192-68-1-x，我设置成-172-10-168-2会怎么样"><a href="#如果身边的人的IP都是192-68-1-x，我设置成-172-10-168-2会怎么样" class="headerlink" title="如果身边的人的IP都是192.68.1.x，我设置成 172.10.168.2会怎么样"></a>如果身边的人的IP都是192.68.1.x，我设置成 172.10.168.2会怎么样</h3><p>包发不出去，因为linux会首先判断这个ip和本机是一个网段的吗？只有是一个网段才会发送ARP协议获取MAC地址。如果判断不是同一网段，Linux 默认的逻辑是，如果这是一个跨网段的调用，它便不会直接将包发送到网络上，而是企图将包发送到网关。所以如果你要配置ip一定要问好你的网络管理员，人少还行，如果每个人都去问那管理员会疯的，所以有了DHCP</p><h3 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h3><p>Dynamic Host Configuration Protocol</p><p>有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的 IP 地址。每一台新接入的机器都通过 DHCP 协议，来这个共享的 IP 地址里申请，然后自动配置好就可以了。等人走了，或者用完了，还回去，这样其他的机器也能用。</p><h3 id="DHCP工作模式"><a href="#DHCP工作模式" class="headerlink" title="DHCP工作模式"></a>DHCP工作模式</h3><h4 id="第一步（DHCP-Discover）"><a href="#第一步（DHCP-Discover）" class="headerlink" title="第一步（DHCP Discover）"></a>第一步（DHCP Discover）</h4><p>新来的机器使用 IP 地址 0.0.0.0 发送了一个广播包，目的 IP 地址为 255.255.255.255。广播包封装了 UDP，UDP 封装了 BOOTP。其实 DHCP 是 BOOTP 的增强版，但是如果你去抓包的话，很可能看到的名称还是 BOOTP 协议。 在这个广播包里面，新人大声喊：我是新来的（Boot request），我的 MAC 地址是这个，我还没有 IP，谁能给租给我个 IP 地址！</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815082342442.png" alt="image-20190815082342442"></p><p>#### </p><h4 id="第二步（DHCP-Offer）"><a href="#第二步（DHCP-Offer）" class="headerlink" title="第二步（DHCP Offer）"></a>第二步（DHCP Offer）</h4><p>如果配置了DHCP server，他会立马知道来了个新人，是通过MAC地址判断的，所以唯一的MAC地址是多么重要。他会立马回DHCP Offer，DHCP Server 仍然使用广播地址作为目的地址，因为，此时请求分配 IP 的新人还没有自己的 IP。DHCP Server 回复说，我分配了一个可用的 IP 给你，你看如何？除此之外，服务器还发送了子网掩码、网关和 IP 地址租用期等信息。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815082810510.png" alt="image-20190815082810510"></p><h4 id="第三步（选一个Offer）"><a href="#第三步（选一个Offer）" class="headerlink" title="第三步（选一个Offer）"></a>第三步（选一个Offer）</h4><p>新来的机器很开心，它的广播得到了回复，并且有人愿意租给它一个 IP 地址了，这意味着它可以在网络上立足了。</p><p>当然更令人开心的是，如果有多个 DHCP Server，这台新机器会收到多个 IP 地址，简直受宠若惊。  它会选择其中一个 DHCP Offer，一般是最先到达的那个，并且会向网络发送一个 DHCP Request 广播数据包，包中包含客户端的 MAC 地址、接受的租约中的 IP 地址、提供此租约的 DHCP 服务器地址等，并告诉所有 DHCP Server 它将接受哪一台服务器提供的 IP 地址，告诉其他 DHCP 服务器，谢谢你们的接纳，并请求撤销它们提供的 IP 地址，以便提供给下一个 IP 租用请求者。</p><p>此时，由于还没有得到 DHCP Server 的最后确认，客户端仍然使用 0.0.0.0 为源 IP 地址、255.255.255.255 为目标地址进行广播。在 BOOTP 里面，接受某个 DHCP Server 的分配的 IP。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815083218963.png" alt="image-20190815083218963"></p><h4 id="第四步（DHCP-Server-Ack）"><a href="#第四步（DHCP-Server-Ack）" class="headerlink" title="第四步（DHCP Server Ack）"></a>第四步（DHCP Server Ack）</h4><p>当 DHCP Server 接收到客户机的 DHCP request 之后，会广播返回给客户机一个 DHCP ACK 消息包，表明已经接受客户机的选择，并将这一 IP 地址的合法租用信息和其他的配置信息都放入该广播包，发给客户机，欢迎它加入网络大家庭。</p><p>最终租约达成的时候，还是需要广播一下，让大家都知道一下。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815083442134.png" alt="image-20190815083442134"></p><h3 id="IP地址的收回与续租"><a href="#IP地址的收回与续租" class="headerlink" title="IP地址的收回与续租"></a>IP地址的收回与续租</h3><p>既然是租房子，就是有租期的。租期到了，管理员就要将 IP 收回。  如果不用的话，收回就收回了。就像你租房子一样，如果还要续租的话，不能到了时间再续租，而是要提前一段时间给房东说。DHCP 也是这样。  客户机会在租期过去 50% 的时候，直接向为其提供 IP 地址的 DHCP Server 发送 DHCP request 消息包。客户机接收到该服务器回应的 DHCP ACK 消息包，会根据包中所提供的新的租期以及其他已经更新的 TCP/IP 参数，更新自己的配置。这样，IP 租用更新就完成了。</p><h3 id="HUB"><a href="#HUB" class="headerlink" title="HUB"></a>HUB</h3><p>有一个叫作Hub的东西，也就是集线器。这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</p><p>你可能已经发现问题了。Hub 采取的是广播的模式，如果每一台电脑发出的包，宿舍的每个电脑都能收到，那就麻烦了。这就需要解决几个问题：包是发给谁的，顺序，包是否完整，这几个问题都是MAC层需要解决的</p><h3 id="MAC层如何解决上述问题"><a href="#MAC层如何解决上述问题" class="headerlink" title="MAC层如何解决上述问题"></a>MAC层如何解决上述问题</h3><h4 id="根据ip如何获取MAC地址"><a href="#根据ip如何获取MAC地址" class="headerlink" title="根据ip如何获取MAC地址"></a>根据ip如何获取MAC地址</h4><p>根据IP地址获取MAC地址</p><p>####第一个问题，发给谁，谁接收？</p><p>这里用到一个物理地址，叫作链路层地址。但是因为第二层主要解决媒体接入控制的问题，所以它常被称为MAC 地址。  解决第一个问题就牵扯到第二层的网络包格式。对于以太网，第二层的最开始，就是目标的 MAC 地址和源的 MAC 地址。</p><h4 id="第二个问题，顺序问题"><a href="#第二个问题，顺序问题" class="headerlink" title="第二个问题，顺序问题"></a>第二个问题，顺序问题</h4><p>MAC的全称是<strong>Medium Access Control</strong>，即媒体访问控制。控制什么呢？其实就是控制在往媒体上发数据的时候，谁先发、谁后发的问题。防止发生混乱。这解决的是第二个问题。这个问题中的规则，学名叫多路访问。有很多算法可以解决这个问题。就像车管所管束马路上跑的车，能想的办法都想过了。</p><ul><li><p>方式一：分多个车道。每个车一个车道，你走你的，我走我的。这在计算机网络里叫作<strong>信道划分</strong>；  </p></li><li><p>方式二：今天单号出行，明天双号出行，轮着来。这在计算机网络里叫作<strong>轮流协议</strong>；  </p></li><li><p>方式三：不管三七二十一，有事儿先出门，发现特堵，就回去。错过高峰再出。我们叫作<strong>随机接入协议</strong>。著名的以太网，用的就是这个方式。</p></li></ul><h4 id="第三个问题，如何校验包是否完整"><a href="#第三个问题，如何校验包是否完整" class="headerlink" title="第三个问题，如何校验包是否完整"></a>第三个问题，如何校验包是否完整</h4><p>对于以太网，第二层的最后面是CRC，也就是循环冗余检测。通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误，主要解决第三个问题。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815085131527.png" alt="image-20190815085131527"></p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>一旦机器数目增多，问题就出现了。因为 Hub 是广播的，不管某个接口是否需要，所有的 Bit 都会被发送出去，然后让主机来判断是不是需要。这种方式路上的车少就没问题，车一多，产生冲突的概率就提高了。而且把不需要的包转发过去，纯属浪费。看来 Hub 这种不管三七二十一都转发的设备是不行了，需要点儿智能的。因为每个口都只连接一台电脑，这台电脑又不怎么换 IP 和 MAC 地址，只要记住这台电脑的 MAC 地址，如果目标 MAC 地址不是这台电脑的，这个口就不用转发了。  谁能知道目标 MAC 地址是否就是连接某个口的电脑的 MAC 地址呢？这就需要一个能把 MAC 头拿下来，检查一下目标 MAC 地址，然后根据策略转发的设备，这个设备是个二层设备，我们称为交换机。</p><p>交换机是有 MAC 地址学习能力的，学完了它就知道谁在哪儿了，不用广播了。</p><h3 id="拓扑结构怎么形成的"><a href="#拓扑结构怎么形成的" class="headerlink" title="拓扑结构怎么形成的"></a>拓扑结构怎么形成的</h3><p>当机器变得很多的时候，一个交换机肯定不够用，需要多台交换机，交换机之间连接起来，就形成一个稍微复杂的拓扑结构。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815085800720.png" alt="image-20190815085800720"></p><h3 id="如何解决拓扑结构中的环路问题"><a href="#如何解决拓扑结构中的环路问题" class="headerlink" title="如何解决拓扑结构中的环路问题"></a>如何解决拓扑结构中的环路问题</h3><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815085848811.png" alt="image-20190815085848811"></p><p>需要<strong>STP协议</strong>来解决</p><h3 id="STP协议"><a href="#STP协议" class="headerlink" title="STP协议"></a>STP协议</h3><p>在数据结构中，有一个方法叫作<strong>最小生成树</strong>。有环的我们常称为图。将图中的环破了，就生成了树。在计算机网络中，生成树的算法叫作<strong>STP</strong>，全称Spanning Tree Protocol。</p><h3 id="如何解决广播问题和安全问题？"><a href="#如何解决广播问题和安全问题？" class="headerlink" title="如何解决广播问题和安全问题？"></a>如何解决广播问题和安全问题？</h3><p>毕竟机器多了，交换机也多了，就算交换机比 Hub 智能一些，但是还是难免有广播的问题，一大波机器，相关的部门、不相关的部门，广播一大堆，性能就下来了。就像一家公司，创业的时候，一二十个人，坐在一个会议室，有事情大家讨论一下，非常方便。但是如果变成了 50 个人，全在一个会议室里面吵吵，就会乱的不得了。有两种解决方法，物理隔离、虚拟隔离</p><h4 id="物理隔离"><a href="#物理隔离" class="headerlink" title="物理隔离"></a>物理隔离</h4><p>每个部门设一个单独的会议室，对应到网络方面，就是每个部门有单独的交换机，配置单独的子网，这样部门之间的沟通就需要路由器了。路由器咱们还没讲到，以后再说。这样的问题在于，有的部门人多，有的部门人少。人少的部门慢慢人会变多，人多的部门也可能人越变越少。如果每个部门有单独的交换机，口多了浪费，少了又不够用。</p><h4 id="虚拟隔离"><a href="#虚拟隔离" class="headerlink" title="虚拟隔离"></a>虚拟隔离</h4><p>就是用我们常说的<strong>VLAN</strong>，或者叫<strong>虚拟局域网</strong>。使用 VLAN，一个交换机上会连属于多个局域网的机器，那交换机怎么区分哪个机器属于哪个局域网呢？</p><p>我们只需要在原来的二层的头上加一个 TAG，里面有一个 VLAN ID，一共 12 位。为什么是 12 位呢？因为 12 位可以划分 4096 个 VLAN。这样是不是还不够啊。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815130704532.png" alt="image-20190815130704532">现在的情况证明，目前云计算厂商里面绝对不止 4096 个用户。当然每个用户需要一个 VLAN 了啊，怎么办呢，这个我们在后面的章节再说。  如果我们买的交换机是支持 VLAN 的，当这个交换机把二层的头取下来的时候，就能够识别这个 VLAN ID。这样只有相同 VLAN 的包，才会互相转发，不同 VLAN 的包，是看不到的。这样广播问题和安全问题就都能够解决了。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815130742460.png" alt="image-20190815130742460"></p><p>有人会问交换机之间怎么连接呢？将两个交换机连接起来的口应该设置成什么 VLAN 呢？对于支持 VLAN 的交换机，有一种口叫作Trunk 口。它可以转发属于任何 VLAN 的口。交换机之间可以通过这种口相互连接。</p><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP全称Internet Control Message Protocol，就是互联网控制报文协议。这里面的关键词是“控制”，那具体是怎么控制的呢。</p><p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。因为作为侦查兵，要轻装上阵，不能携带大量的包袱。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815091433474.png" alt="image-20190815091433474"></p><p>ICMP 报文有很多的类型，不同的类型有不同的代码。<strong>最常用的类型是主动请求为 8,主动请求的应答为0</strong></p><h4 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h4><p>常用的<strong>ping</strong> 就是查询报文，是一种主动请求，并且获得主动应答的 ICMP 协议。所以，ping 发的包也是符合 ICMP 协议格式的，只不过它在后面增加了自己的格式。</p><p><img src="/2019/08/14/《趣谈网络协议》第3-7讲笔记/images/image-20190815205514192.png" alt="image-20190815205514192"></p><h4 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h4><p>Traceroute 使用差错报文,详细请看专栏</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ifconfig-和-ip-addr的区别&quot;&gt;&lt;a href=&quot;#ifconfig-和-ip-addr的区别&quot; class=&quot;headerlink&quot; title=&quot;ifconfig 和 ip addr的区别&quot;&gt;&lt;/a&gt;ifconfig 和 ip addr的区别&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程下hashmap死循环</title>
    <link href="http://shiyangtao.github.io/2019/02/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Bhashmap%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
    <id>http://shiyangtao.github.io/2019/02/16/多线程下hashmap死循环/</id>
    <published>2019-02-16T04:40:00.000Z</published>
    <updated>2019-08-14T07:47:07.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于HashMap并非是线程安全的，所以在高并发的情况下必然会出现问题，可能发生死循环，导致cpu100%，服务重启之后，问题消失，过段时间可能又复现了。<br>这是为什么</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>在了解来龙去脉之前，我们先看看HashMap的数据结构。<br>在内部，HashMap使用一个Entry数组保存key、value数据，当一对key、value被加入时，会通过一个hash算法得到数组的下标index，算法很简单，根据key的hash值，对数组的大小取模 hash &amp; (length-1)，并把结果插入数组该位置，如果该位置上已经有元素了，就说明存在hash冲突，这样会在index位置生成链表。<br>如果存在hash冲突，最惨的情况，就是所有元素都定位到同一个位置，形成一个长长的链表，这样get一个值时，最坏情况需要遍历所有节点，性能变成了O(n)，所以元素的hash值算法和HashMap的初始化大小很重要。<br>当插入一个新的节点时，如果不存在相同的key，则会判断当前内部元素是否已经达到阈值（默认是数组大小的0.75），如果已经达到阈值，会对数组进行扩容，也会对链表中的元素进行rehash。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>HashMap的put方法实现：</p><h4 id="判断key是否已经存在"><a href="#判断key是否已经存在" class="headerlink" title="判断key是否已经存在"></a>判断key是否已经存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 如果key已经存在，则替换value，并返回旧值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// key不存在，则插入新的元素</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查容量是否达到阈值threshold"><a href="#检查容量是否达到阈值threshold" class="headerlink" title="检查容量是否达到阈值threshold"></a>检查容量是否达到阈值threshold</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码如果元素个数已经达到阈值，则扩容，并把原来的元素移动过去。</p><h4 id="扩容实现"><a href="#扩容实现" class="headerlink" title="扩容实现"></a>扩容实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    ...</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会新建一个更大的数组，并通过transfer方法，移动元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>移动的逻辑也很清晰，遍历原来table中每个位置的链表，并对每个元素进行重新hash，在新的newTable找到归宿，并插入。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>假设HashMap初始化大小为4，插入个3节点，不巧的是，这3个节点都hash到同一个位置，如果按照默认的负载因子的话，插入第3个节点就会扩容，为了验证效果，假设负载因子是1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是节点移动的相关逻辑。</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-0.png" alt="upload successful"></p><h4 id="两个线程同时rehash"><a href="#两个线程同时rehash" class="headerlink" title="两个线程同时rehash"></a>两个线程同时rehash</h4><p>插入第4个节点时，发生rehash，假设现在有两个线程同时进行，线程1和线程2，两个线程都会新建新的数组。</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-2.png" alt="upload successful"></p><h4 id="线程2Block线程1继续执行"><a href="#线程2Block线程1继续执行" class="headerlink" title="线程2Block线程1继续执行"></a>线程2Block线程1继续执行</h4><p>假设 <strong>线程2</strong> 在执行到<span style="color:red">Entry&lt;K,V&gt; next = e.next;</span>之后，cpu时间片用完了，这时变量e指向节点a，变量next指向节点b。<br>线程1继续执行，很不巧，a、b、c节点rehash之后又是在同一个位置7，开始移动节点<br>第一步，移动节点a</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-3.png" alt="upload successful"><br>第二步，移动节点b</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-4.png" alt="upload successful"><br>注意，这里的顺序是反过来的，继续移动节点c</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-5.png" alt="upload successful"></p><h4 id="线程1Block线程2开始执行"><a href="#线程1Block线程2开始执行" class="headerlink" title="线程1Block线程2开始执行"></a>线程1Block线程2开始执行</h4><p>这个时候 <strong>线程1</strong> 的时间片用完，内部的table还没有设置成新的newTable， <strong>线程2</strong> 开始执行，这时内部的引用关系如下：</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-6.png" alt="upload successful"></p><h4 id="线程2继续循环剩余逻辑"><a href="#线程2继续循环剩余逻辑" class="headerlink" title="线程2继续循环剩余逻辑"></a>线程2继续循环剩余逻辑</h4><p>这时，在 线程2 中，变量e指向节点a，变量next指向节点b，开始执行循环体的剩余逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure></p><p>执行之后的引用关系如下图<br><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-7.png" alt="upload successful"><br>执行后，变量e指向节点b，因为e不是null，则继续执行循环体</p><h4 id="线程2第二次循环"><a href="#线程2第二次循环" class="headerlink" title="线程2第二次循环"></a>线程2第二次循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>执行后的引用关系<br><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-8.png" alt="upload successful"></p><p>变量e又重新指回节点a，只能继续执行循环体</p><h4 id="线程2第三次循环-出现环"><a href="#线程2第三次循环-出现环" class="headerlink" title="线程2第三次循环(出现环)"></a>线程2第三次循环(出现环)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前节点a没有next，所以变量next指向null；</span></span><br><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="comment">// 其中 newTable[i] 指向节点b，那就是把a的next指向了节点b，这样a和b就相互引用了，形成了一个环</span></span><br><span class="line">e.next = newTable[i]; </span><br><span class="line"><span class="comment">// 把节点a放到了数组i位置；</span></span><br><span class="line">newTable[i] = e </span><br><span class="line"><span class="comment">// 把变量e赋值为null，因为第一步中变量next就是指向null；</span></span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>所以最终的引用关系是这样的：</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-9.png" alt="upload successful"></p><p>节点a和b互相引用，形成了一个环，当在数组该位置get寻找对应的key时，就发生了死循环。<br>另外，如果线程2把newTable设置成到内部的table，节点c的数据就丢了，看来还有数据遗失的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以在并发的情况，发生扩容时，可能会产生循环链表，在执行get的时候，会触发死循环，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。<br>曾经有人把这个问题报给了Sun，不过Sun不认为这是一个bug，因为在HashMap本来就不支持多线程使用，要并发就用ConcurrentHashmap。</p><p>文章参考 占小狼和coolshell的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;由于HashMap并非是线程安全的，所以在高并发的情况下必然会出现问题，可能发生死循环，导致cpu100%，服务重启之后，问题消失，过段时间
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://shiyangtao.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java并发编程" scheme="http://shiyangtao.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://shiyangtao.github.io/2019/02/13/ThreadLocal/"/>
    <id>http://shiyangtao.github.io/2019/02/13/ThreadLocal/</id>
    <published>2019-02-13T09:42:00.000Z</published>
    <updated>2019-08-14T07:47:19.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><p>jdk文档介绍<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class="line"><span class="comment"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125; or &#123;<span class="doctag">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class="line"><span class="comment"> * copy of the variable.  &#123;<span class="doctag">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class="line"><span class="comment"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class="line"><span class="comment"> * a user ID or Transaction ID).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> * A thread's id is assigned the first time it invokes &#123;<span class="doctag">@code</span> ThreadId.get()&#125;</span></span><br><span class="line"><span class="comment"> * and remains unchanged on subsequent calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>结合我的总结可以这样理解：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离～。<br>简要言之：往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。</p><h3 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h3><p>从上面可以得出：ThreadLocal可以让我们拥有当前线程的变量，那这个作用有什么用呢？？？<br>最常见的ThreadLocal使用场景为用来解决 数据库连接、Session管理、避免一些参数传递等<br>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">= <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>Thread、ThreadLocal、ThreadLocalMap、Entry之间的关系</strong><br><img src="/2019/02/13/ThreadLocal/images/pasted-1.png" alt="Thread、ThreadLocal、ThreadLocalMap、Entry之间的关系"></p><p>ThreadLocal的实现是这样的：每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</p><p>也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的是图中的虚线，表示 ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</p><p><img src="/2019/02/13/ThreadLocal/images/pasted-0.png" alt="upload successful"></p><p>ThreadLocalMap由一个个Entry对象构成，Entry的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Entry继承自WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，一个Entry由ThreadLocal对象和Object构成。由此可见，Entry的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收。</p><p>那么，ThreadLocal是如何工作的呢？下面来看set和get方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h3><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如线程池线程循环利用)，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。</p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><ul><li>使用static的ThreadLocal有外部强引用，延长了ThreadLocal的生命周期，可能导致的内存泄漏</li><li>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。(虽然ThreadLocal回收了但是value没有被回收)</li></ul><h4 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h4><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p><p>我们先来看看官方文档的说法：</p><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p><p>下面我们分两种情况讨论：</p><ul><li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</li></ul><p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><p>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。<br>在使用线程池的情况下，thread的生命周期很长的情况下，没有及时清理ThreadLocal，导致内存泄漏随着应用运行的时间越来越长会导致内存溢出。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h3&gt;&lt;p&gt;jdk文档介绍&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://shiyangtao.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://shiyangtao.github.io/2019/01/29/%E9%93%BE%E8%A1%A8/"/>
    <id>http://shiyangtao.github.io/2019/01/29/链表/</id>
    <published>2019-01-29T05:29:25.000Z</published>
    <updated>2019-08-14T07:46:51.939Z</updated>
    
    <content type="html"><![CDATA[<p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p><h3 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h3><p>为了直观地对比，我画了一张图。从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。<br>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><p><img src="/2019/01/29/链表/images/pasted-0.png" alt="upload successful"></p><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的<strong>“结点”</strong>。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>“后继指针”</strong></p><p><img src="/2019/01/29/链表/images/pasted-1.png" alt="upload successful"><br>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p><img src="/2019/01/29/链表/images/pasted-2.png" alt="upload successful"></p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。<br><img src="/2019/01/29/链表/images/pasted-3.png" alt="upload successful"><br>和单链表相比，<strong>循环列表的优点是</strong>是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br><img src="/2019/01/29/链表/images/pasted-4.png" alt="upload successful"><br>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；<br>这种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</li></ul><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><ul><li>删除给定指针指向的结点。<br>对于这种种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</li></ul><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 Java 语言，你肯定用过 LinkedHashMap 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是<strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="/2019/01/29/链表/images/pasted-5.png" alt="upload successful"></p><h3 id="数组vs链表性能比拼"><a href="#数组vs链表性能比拼" class="headerlink" title="数组vs链表性能比拼"></a>数组vs链表性能比拼</h3><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="/2019/01/29/链表/images/pasted-6.png" alt="upload successful"></p><h3 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h3><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h3 id="链表实现LRU缓存"><a href="#链表实现LRU缓存" class="headerlink" title="链表实现LRU缓存"></a>链表实现LRU缓存</h3><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果次数据不在链表里<ul><li>链表满了，删除尾结点，该数据插入头结点</li><li>链表还有空间，插入头结点</li></ul></li></ol><p><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/link/LinkedLRU.java" target="_blank" rel="noopener">代码地址</a><br>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="数组实现LRU缓存"><a href="#数组实现LRU缓存" class="headerlink" title="数组实现LRU缓存"></a>数组实现LRU缓存</h4><p>除了基于链表的实现思路，实际上还可以用数组来实现 LRU 缓存淘汰策略。如何利用数组实现 LRU 缓存淘汰策略呢？我把这个问题留给你思考。<br>我的思路是这样：维护一个数组，越靠近尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从数组第一个元素开始遍历</p><ol><li>如果此数据已经被缓存，我们遍历得到这个数据的下标，并将前面的所有数据都往右移动一位，然后在把该元素放到数据下标0的位置</li><li>如果数组不在数组里<ul><li>数组满了，把最后一个元素之前的元素向右平移一位，最后一个元素自然也就丢弃了，然后把该数据放到下标为0的位置</li><li>数组还有空间，把数组里所有元素向右平移一位，然后把该数据放到下标为0的位置<br><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/array/ArrayLRU.java" target="_blank" rel="noopener">代码地址</a><br>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍数组，所以这种基于数组的实现思路，缓存访问的时间复杂度为 O(n)。</li></ul></li></ol><h4 id="如何判断一个字符串是回文串"><a href="#如何判断一个字符串是回文串" class="headerlink" title="如何判断一个字符串是回文串"></a>如何判断一个字符串是回文串</h4><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的思题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？<br>我的思路是：使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。<br><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/link/Palindrome.java" target="_blank" rel="noopener">代码地址</a></p><h4 id="常见单链表编程题"><a href="#常见单链表编程题" class="headerlink" title="常见单链表编程题"></a>常见单链表编程题</h4><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序链表合并</li><li>删除倒数第n个代码</li><li>求链表中间结点<br><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/link/LinkProblem.java" target="_blank" rel="noopener">代码地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。&lt;/p&gt;
&lt;h3 id=&quot;链表和数组的区别&quot;&gt;&lt;a href=&quot;#链表和数组的区别&quot; 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://shiyangtao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://shiyangtao.github.io/2019/01/29/%E6%95%B0%E7%BB%84/"/>
    <id>http://shiyangtao.github.io/2019/01/29/数组/</id>
    <published>2019-01-29T02:31:00.000Z</published>
    <updated>2019-08-14T07:46:38.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何实现随机访问"><a href="#如何实现随机访问" class="headerlink" title="如何实现随机访问"></a>如何实现随机访问</h3><p>什么是数组？数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><p>这个定义里有几个关键词</p><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="/2019/01/29/数组/images/pasted-0.png" alt="upload successful"><br>而与他对立的是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="/2019/01/29/数组/images/pasted-1.png" alt="upload successful"></p><h4 id="连续的内存空间和相同类型的数据"><a href="#连续的内存空间和相同类型的数据" class="headerlink" title="连续的内存空间和相同类型的数据"></a>连续的内存空间和相同类型的数据</h4><p>正是有了这个特性，他才有了随机访问这个“杀手锏”。但是有利就有弊，比如删除添加为了保证连续性，必须要做数据搬移工作。<br>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？<br>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10] 来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><p><img src="/2019/01/29/数组/images/pasted-2.png" alt="upload successful"><br>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure></p><p>其中data_type_size表示每个元素的大小。我们这个例子数组中存储的是int类型数组，所以date_type_size就为4个字节。<br>这里特别纠正一个“错误”。面试中经常会问到数组和链表的区别，很多人都会回答，“链表适合插入、删除、时间复杂度O(1);数组适合查找，查找时间复杂度为O(1)”。<br>实际上，这种表述是不准确的。数组是适合查找操作，但查找时间复杂度不是O(1)。即便是排序好的数组，你用二分查找时间复杂度才是O(logn)。所以正确的表述是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p><h3 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h3><p>前面提到，数组为了保证内存数组连续性，会导致插入、删除两个操作会比较低效。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设数组长度为n，现在，需要把一个数据插入到数组第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要把k～n这部分元素都顺序往后挪一下，那时间复杂度是多少呢？<br>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。<br>如果数组中的数据是有序的，我们在某个位置插入一个新元素，就必须按照刚才的方法搬移k之后的数组。但是如果数组中的数据没有任何规律，数组只是存储集合。在这种情况下，如果把数据插入第k个位置，为了避免大规模搬移，直接将第k个位置的数据插入到数组最后，把新的元素放在第k个位置。如下图所示</p><p><img src="/2019/01/29/数组/images/pasted-3.png" alt="upload successful"><br>利用这个技巧，在特定场景下，在第k个位置插入元素的复杂度就降到了O(1)</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>跟插入操作类似，如果删除第k个位置的数据，为了内存连续性，也需要搬移数据，不然会出现空洞，内存就不连续了。<br>和插入类似，如果删除末尾的数据，时间复杂度O(1);如果删除开头的数据，则最坏情况时间复杂度为O(n);平均情况时间复杂度也为O(n)。<br>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？<br>我们继续来看例子。数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src="/2019/01/29/数组/images/pasted-4.png" alt="upload successful"><br>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。</p><h3 id="容器能否代替数组？"><a href="#容器能否代替数组？" class="headerlink" title="容器能否代替数组？"></a>容器能否代替数组？</h3><p>针对数组类型，很多语言提供了容器类，比如java中的ArrayList。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？<br>因为我是java开发，几乎每天都在用ArrayList。个人觉得ArrayList的最大优势就是可以把很多数组操作的细节封装起来。比如插入、删除、动态扩容。</p><p>数组本身在定义时需要预先指定大小，因为需要分配连续的内存空间。乳沟我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后在插入新的数据。</p><p>如果使用ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList已经帮我们实现好了。每次空间不够时，他都会自动扩容为1.5倍大小。</p><p>不过，这里需要注意一点，因为扩容需要内存申请和数据搬移，比较耗时。所以，如果事先能去定需要存储数据的大小，最后在创建ArrayList的时候事先指定数据大小。</p><p>作为高级语言编程者，是不是数组就无用武之地了？当然不是，一下情况可以用数组。</p><ol><li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li><li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li><li>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<arraylist> array。</arraylist></li></ol><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><h3 id="为什么大多数编程语言数组下标要从0开始而不是1"><a href="#为什么大多数编程语言数组下标要从0开始而不是1" class="headerlink" title="为什么大多数编程语言数组下标要从0开始而不是1"></a>为什么大多数编程语言数组下标要从0开始而不是1</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure></p><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure></p><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。</p><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何实现随机访问&quot;&gt;&lt;a href=&quot;#如何实现随机访问&quot; class=&quot;headerlink&quot; title=&quot;如何实现随机访问&quot;&gt;&lt;/a&gt;如何实现随机访问&lt;/h3&gt;&lt;p&gt;什么是数组？数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://shiyangtao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://shiyangtao.github.io/2019/01/26/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://shiyangtao.github.io/2019/01/26/策略模式/</id>
    <published>2019-01-26T04:19:00.000Z</published>
    <updated>2019-08-14T07:46:44.445Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一版鸭子游戏"><a href="#第一版鸭子游戏" class="headerlink" title="第一版鸭子游戏"></a>第一版鸭子游戏</h4><p>我们设计了一个鸭子游戏项目，游戏中会出现各种鸭子，为此Joe实现了一个超类Duck，让鸭子子类都继承这个类，如下图所示。<br><img src="/2019/01/26/策略模式/images/pasted-0.png" alt="upload successful"></p><h4 id="加鸭子会飞的需求"><a href="#加鸭子会飞的需求" class="headerlink" title="加鸭子会飞的需求"></a>加鸭子会飞的需求</h4><h5 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h5><p>过了几天主管找到Joe说希望有的鸭子能飞，Joe说so easy，只需在超类里增加一个fly()方法就ok了。<br><img src="/2019/01/26/策略模式/images/pasted-1.png" alt="upload successful"><br>但是过了几天主管对外演示时发现，橡皮鸭子在屏幕上飞来飞去，非常尴尬。主管打电话开始喷Joe:你可以去看看boss直聘了。<br>Joe忽略了一件事，并非所有鸭子都会飞，他在超类里加上新的行为，会使得不该拥有这个行为的子类也拥有了这个行为。他体会了一件事：当涉及维护时为了复用目的使用继承结局并不完美。</p><p>Joe：那么橡皮鸭子类可以重写这个fly方法里边什么也不做，不就可以了吗？<br>主管：那么所有不能飞的子类都得重写一遍fly，然后如果加入木鸭(不会飞不会叫)，也得把quack()方法重写。<br>Joe意思到继承可能无法解决这个问题：</p><h5 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h5><p>Joe：那么可以把fly()和quack()方法从超类里拆出来，只有能飞/能叫的鸭子子类实现这个接口<br><img src="/2019/01/26/策略模式/images/pasted-2.png" alt="upload successful"><br>主管：这真是个超级糟糕的设计，如果你认为重写几个方法很差劲，但是48个子类都稍微修改下飞行的行为呢？<br>Joe：我去还真是，虽然Flayable和Quackable能解决一部分问题（不再有会飞的橡皮鸭），但是却造成代码无法复用啊，每个会飞的鸭子子类都得实现一个fly()方法哪怕他们的飞的行为是一样的，如果每个fly方法里增加打印日志得需要改48个子类。那咋办呀？</p><h4 id="设计原则一"><a href="#设计原则一" class="headerlink" title="设计原则一"></a>设计原则一</h4><p>主管：把问题归零把，下面给你介绍一个设计原则：找出应用中可能需要变化的地方，把他们独立出来，不要在和哪些不变的代码混在一起了，把会变化的代码封装起来，好让其他部分不受影响，代码变化引起的bug变少，系统更加有弹性</p><p><img src="/2019/01/26/策略模式/images/pasted-3.png" alt="upload successful"><br>下面是这个设计原则的另一种思考方式：“把会变化的部分取出并封装起来，以便以后可以轻易的改动或者扩展此部分，而不影响不需要变化的部分“<br>主管：Joe是时候把鸭子的行为从Duck里行为拆出来了！<br>Joe：ok，那么Duck里的行为除了fly和quack有问题外，其他行为一切还算正常，现在要分开变化部分和不变部分了，我打算建立两组类看图</p><h4 id="设计原则二"><a href="#设计原则二" class="headerlink" title="设计原则二"></a>设计原则二</h4><p><img src="/2019/01/26/策略模式/images/pasted-4.png" alt="upload successful"><br>那么如何设计那组实现飞行和呱呱叫的的行为的类呢？我们希望一切能有弹性，毕竟，正是一开始鸭子行为没有弹性，才让我们走上现在这条路。我们还想能够“指定”行为到鸭子的实例。比方说，我们想要产生一个新的绿头鸭的实例，并指定特定的“类型”的飞行行为给它。干脆让鸭子的行为可以动态地改变好了。换句话说，我们应该在鸭子类中包含设定行为的方法，这样就可以在“运行时”动态地“改变”绿头鸭的飞行行为。有了这些目标要实现，接着看看第二个设计原则：</p><p><img src="/2019/01/26/策略模式/images/pasted-5.png" alt="upload successful"><br>我们利用接口代表每个行为，比方说，FlyBehavior和QuackBehavior接口。所以这次鸭子类不回负责实现Fly与Quack接口，反而是由我们制造一组其他类专门实现FlyBehavior与QuackBehavior,这些就称为“行为”类。</p><p><img src="/2019/01/26/策略模式/images/pasted-7.png" alt="upload successful"><br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。<br>而我们可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。这么一来，有了继承的“复用”的好处，却没有继承所带来的包袱。</p><h4 id="整合鸭子的行为"><a href="#整合鸭子的行为" class="headerlink" title="整合鸭子的行为"></a>整合鸭子的行为</h4><p>关键在于，鸭子现在会将飞行和呱呱叫“委托”(delegate)别人处理，而不是定义在Duck类(或子类)内的呱呱叫和飞行方法。</p><p><img src="/2019/01/26/策略模式/images/pasted-8.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="comment">//每只鸭子都会引用实现QuackBehavior接口的对象。</span></span><br><span class="line">QuackBehavior quackBehavior;</span><br><span class="line">    <span class="comment">// 还有更多</span></span><br><span class="line">    .......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//鸭子对象不亲自处理呱呱叫的行为，而是委托给quackBehavior引用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    quckBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/2019/01/26/策略模式/images/pasted-9.png" alt="upload successful"></p><h4 id="设计原则三"><a href="#设计原则三" class="headerlink" title="设计原则三"></a>设计原则三</h4><p>“有一个”可能比“是一个”更好。<br>“有一个”关系相当有趣：每一鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和呱呱叫委托给它们代为处理。<br>当你将两个类结合起来使用，如同本例一般，这就是组合(composition)。这种做法和“继承”不同的地方在于，鸭子的行为不是继承来的，而是和适当的行为对像“组合来的”。这是一个很重要的技巧。其实是使用了我们的第三个设计原则：</p><p><img src="/2019/01/26/策略模式/images/pasted-10.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一版鸭子游戏&quot;&gt;&lt;a href=&quot;#第一版鸭子游戏&quot; class=&quot;headerlink&quot; title=&quot;第一版鸭子游戏&quot;&gt;&lt;/a&gt;第一版鸭子游戏&lt;/h4&gt;&lt;p&gt;我们设计了一个鸭子游戏项目，游戏中会出现各种鸭子，为此Joe实现了一个超类Duck，让鸭子子类都继承
      
    
    </summary>
    
      <category term="设计模式" scheme="http://shiyangtao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://shiyangtao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>shell启动socket</title>
    <link href="http://shiyangtao.github.io/2018/12/03/shell%E5%90%AF%E5%8A%A8socket/"/>
    <id>http://shiyangtao.github.io/2018/12/03/shell启动socket/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:13:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>nc -l localhost 3000 server<br>nc localhost 3000 client</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nc -l localhost 3000 server&lt;br&gt;nc localhost 3000 client&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://shiyangtao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grep</title>
    <link href="http://shiyangtao.github.io/2018/11/03/grep/"/>
    <id>http://shiyangtao.github.io/2018/11/03/grep/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>grep 后面带上-A -B -C 参数可以多显示几行内容</p><p>grep -A 5 可以显示匹配内容以及后面的5行内容<br>grep -B 5 可以显示匹配内容以及前面的5行内容<br>grep -C 5 可以显示匹配内容以及前后面的5行内容</p><p>grep “” logfile|wc -l 显示匹配的行数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;grep 后面带上-A -B -C 参数可以多显示几行内容&lt;/p&gt;
&lt;p&gt;grep -A 5 可以显示匹配内容以及后面的5行内容&lt;br&gt;grep -B 5 可以显示匹配内容以及前面的5行内容&lt;br&gt;grep -C 5 可以显示匹配内容以及前后面的5行内容&lt;/p&gt;
&lt;p&gt;gr
      
    
    </summary>
    
    
      <category term="linux" scheme="http://shiyangtao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在同一个类中，一个方法调用另外一个有注解（比如@Async，@Transational）的方法，注解失效的原因和解决方法</title>
    <link href="http://shiyangtao.github.io/2016/12/05/%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E6%9C%89%E6%B3%A8%E8%A7%A3%EF%BC%88%E6%AF%94%E5%A6%82@Async%EF%BC%8C@Transational%EF%BC%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://shiyangtao.github.io/2016/12/05/在同一个类中，一个方法调用另外一个有注解（比如@Async，@Transational）的方法，注解失效的原因和解决方法/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2019-01-26T01:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/clementad/article/details/47339519" target="_blank" rel="noopener">https://blog.csdn.net/clementad/article/details/47339519</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/clementad/article/details/47339519&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/clementad/article
      
    
    </summary>
    
    
      <category term="spring" scheme="http://shiyangtao.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="http://shiyangtao.github.io/2015/01/31/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://shiyangtao.github.io/2015/01/31/动态代理/</id>
    <published>2015-01-31T06:54:00.000Z</published>
    <updated>2019-08-14T07:46:29.700Z</updated>
    
    <content type="html"><![CDATA[<p>java静态代理和动态代理</p><h4 id="代理的优点"><a href="#代理的优点" class="headerlink" title="代理的优点"></a>代理的优点</h4><ul><li><p>职责清晰 真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。</p></li><li><p>代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。</p></li><li><p>高扩展性，可以在代理方法前后增加额外的处理逻辑。</p></li></ul><h4 id="被代理的对象"><a href="#被代理的对象" class="headerlink" title="被代理的对象"></a>被代理的对象</h4><p>一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println( <span class="string">"call doSomething()"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。缺点是被代理对象和代理紧耦合在一起。而且代理类都是针对被代理类创建的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    Subject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>); <span class="comment">//调用目标对象之前可以做相关操作</span></span><br><span class="line">        subject.doSomething();</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);<span class="comment">//调用目标对象之后可以做相关操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理在运行阶段才指定被代理的对象，通过实现InvocationHandler接口，调用具体的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object tar;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object tar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tar = tar;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(tar.getClass().getClassLoader(), tar.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>); <span class="comment">//调用目标对象之前可以做相关操作</span></span><br><span class="line">        result = method.invoke(tar, args);</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);<span class="comment">//调用目标对象之后可以做相关操作</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyHandler proxy = <span class="keyword">new</span> ProxyHandler();</span><br><span class="line">        <span class="comment">//绑定该类实现的所有接口</span></span><br><span class="line">        Subject sub = (Subject) proxy.bind(<span class="keyword">new</span> SubjectImpl());</span><br><span class="line">        sub.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java静态代理和动态代理&lt;/p&gt;
&lt;h4 id=&quot;代理的优点&quot;&gt;&lt;a href=&quot;#代理的优点&quot; class=&quot;headerlink&quot; title=&quot;代理的优点&quot;&gt;&lt;/a&gt;代理的优点&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;职责清晰 真实的角色就是实现实际的业务逻辑，不用关心其他
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://shiyangtao.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
