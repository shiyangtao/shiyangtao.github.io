<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shiyangtao&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shiyangtao.github.io/"/>
  <updated>2019-02-16T07:13:59.000Z</updated>
  <id>http://shiyangtao.github.io/</id>
  
  <author>
    <name>sytao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程下hashmap死循环</title>
    <link href="http://shiyangtao.github.io/2019/02/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Bhashmap%E6%AD%BB%E5%BE%AA%E7%8E%AF/"/>
    <id>http://shiyangtao.github.io/2019/02/16/多线程下hashmap死循环/</id>
    <published>2019-02-16T04:40:00.000Z</published>
    <updated>2019-02-16T07:13:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于HashMap并非是线程安全的，所以在高并发的情况下必然会出现问题，可能发生死循环，导致cpu100%，服务重启之后，问题消失，过段时间可能又复现了。<br>这是为什么</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>在了解来龙去脉之前，我们先看看HashMap的数据结构。<br>在内部，HashMap使用一个Entry数组保存key、value数据，当一对key、value被加入时，会通过一个hash算法得到数组的下标index，算法很简单，根据key的hash值，对数组的大小取模 hash &amp; (length-1)，并把结果插入数组该位置，如果该位置上已经有元素了，就说明存在hash冲突，这样会在index位置生成链表。<br>如果存在hash冲突，最惨的情况，就是所有元素都定位到同一个位置，形成一个长长的链表，这样get一个值时，最坏情况需要遍历所有节点，性能变成了O(n)，所以元素的hash值算法和HashMap的初始化大小很重要。<br>当插入一个新的节点时，如果不存在相同的key，则会判断当前内部元素是否已经达到阈值（默认是数组大小的0.75），如果已经达到阈值，会对数组进行扩容，也会对链表中的元素进行rehash。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>HashMap的put方法实现：</p><h4 id="判断key是否已经存在"><a href="#判断key是否已经存在" class="headerlink" title="判断key是否已经存在"></a>判断key是否已经存在</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 如果key已经存在，则替换value，并返回旧值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// key不存在，则插入新的元素</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查容量是否达到阈值threshold"><a href="#检查容量是否达到阈值threshold" class="headerlink" title="检查容量是否达到阈值threshold"></a>检查容量是否达到阈值threshold</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制代码如果元素个数已经达到阈值，则扩容，并把原来的元素移动过去。</p><h4 id="扩容实现"><a href="#扩容实现" class="headerlink" title="扩容实现"></a>扩容实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    ...</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会新建一个更大的数组，并通过transfer方法，移动元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>移动的逻辑也很清晰，遍历原来table中每个位置的链表，并对每个元素进行重新hash，在新的newTable找到归宿，并插入。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>假设HashMap初始化大小为4，插入个3节点，不巧的是，这3个节点都hash到同一个位置，如果按照默认的负载因子的话，插入第3个节点就会扩容，为了验证效果，假设负载因子是1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上是节点移动的相关逻辑。</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-0.png" alt="upload successful"></p><h4 id="两个线程同时rehash"><a href="#两个线程同时rehash" class="headerlink" title="两个线程同时rehash"></a>两个线程同时rehash</h4><p>插入第4个节点时，发生rehash，假设现在有两个线程同时进行，线程1和线程2，两个线程都会新建新的数组。</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-2.png" alt="upload successful"></p><h4 id="线程2Block线程1继续执行"><a href="#线程2Block线程1继续执行" class="headerlink" title="线程2Block线程1继续执行"></a>线程2Block线程1继续执行</h4><p>假设 <strong>线程2</strong> 在执行到<span style="color:red">Entry&lt;K,V&gt; next = e.next;</span>之后，cpu时间片用完了，这时变量e指向节点a，变量next指向节点b。<br>线程1继续执行，很不巧，a、b、c节点rehash之后又是在同一个位置7，开始移动节点<br>第一步，移动节点a</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-3.png" alt="upload successful"><br>第二步，移动节点b</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-4.png" alt="upload successful"><br>注意，这里的顺序是反过来的，继续移动节点c</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-5.png" alt="upload successful"></p><h4 id="线程1Block线程2开始执行"><a href="#线程1Block线程2开始执行" class="headerlink" title="线程1Block线程2开始执行"></a>线程1Block线程2开始执行</h4><p>这个时候 <strong>线程1</strong> 的时间片用完，内部的table还没有设置成新的newTable， <strong>线程2</strong> 开始执行，这时内部的引用关系如下：</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-6.png" alt="upload successful"></p><h4 id="线程2继续循环剩余逻辑"><a href="#线程2继续循环剩余逻辑" class="headerlink" title="线程2继续循环剩余逻辑"></a>线程2继续循环剩余逻辑</h4><p>这时，在 线程2 中，变量e指向节点a，变量next指向节点b，开始执行循环体的剩余逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure></p><p>执行之后的引用关系如下图<br><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-7.png" alt="upload successful"><br>执行后，变量e指向节点b，因为e不是null，则继续执行循环体</p><h4 id="线程2第二次循环"><a href="#线程2第二次循环" class="headerlink" title="线程2第二次循环"></a>线程2第二次循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">e.next = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>执行后的引用关系<br><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-8.png" alt="upload successful"></p><p>变量e又重新指回节点a，只能继续执行循环体</p><h4 id="线程2第三次循环-出现环"><a href="#线程2第三次循环-出现环" class="headerlink" title="线程2第三次循环(出现环)"></a>线程2第三次循环(出现环)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前节点a没有next，所以变量next指向null；</span></span><br><span class="line">Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="comment">// 其中 newTable[i] 指向节点b，那就是把a的next指向了节点b，这样a和b就相互引用了，形成了一个环</span></span><br><span class="line">e.next = newTable[i]; </span><br><span class="line"><span class="comment">// 把节点a放到了数组i位置；</span></span><br><span class="line">newTable[i] = e </span><br><span class="line"><span class="comment">// 把变量e赋值为null，因为第一步中变量next就是指向null；</span></span><br><span class="line">e = next;</span><br></pre></td></tr></table></figure><p>所以最终的引用关系是这样的：</p><p><img src="/2019/02/16/多线程下hashmap死循环/images/pasted-9.png" alt="upload successful"></p><p>节点a和b互相引用，形成了一个环，当在数组该位置get寻找对应的key时，就发生了死循环。<br>另外，如果线程2把newTable设置成到内部的table，节点c的数据就丢了，看来还有数据遗失的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以在并发的情况，发生扩容时，可能会产生循环链表，在执行get的时候，会触发死循环，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。<br>曾经有人把这个问题报给了Sun，不过Sun不认为这是一个bug，因为在HashMap本来就不支持多线程使用，要并发就用ConcurrentHashmap。</p><p>文章参考 占小狼和coolshell的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;由于HashMap并非是线程安全的，所以在高并发的情况下必然会出现问题，可能发生死循环，导致cpu100%，服务重启之后，问题消失，过段时间
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://shiyangtao.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java并发编程" scheme="http://shiyangtao.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://shiyangtao.github.io/2019/02/13/ThreadLocal/"/>
    <id>http://shiyangtao.github.io/2019/02/13/ThreadLocal/</id>
    <published>2019-02-13T09:42:00.000Z</published>
    <updated>2019-02-14T02:31:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h3><p>jdk文档介绍<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class="line"><span class="comment"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125; or &#123;<span class="doctag">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class="line"><span class="comment"> * copy of the variable.  &#123;<span class="doctag">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class="line"><span class="comment"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class="line"><span class="comment"> * a user ID or Transaction ID).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> * A thread's id is assigned the first time it invokes &#123;<span class="doctag">@code</span> ThreadId.get()&#125;</span></span><br><span class="line"><span class="comment"> * and remains unchanged on subsequent calls.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>结合我的总结可以这样理解：ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离～。<br>简要言之：往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。</p><h3 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h3><p>从上面可以得出：ThreadLocal可以让我们拥有当前线程的变量，那这个作用有什么用呢？？？<br>最常见的ThreadLocal使用场景为用来解决 数据库连接、Session管理、避免一些参数传递等<br>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">= <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line">    Session s = (Session) threadSession.get();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            s = getSessionFactory().openSession();</span><br><span class="line">            threadSession.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>Thread、ThreadLocal、ThreadLocalMap、Entry之间的关系</strong><br><img src="/2019/02/13/ThreadLocal/images/pasted-1.png" alt="Thread、ThreadLocal、ThreadLocalMap、Entry之间的关系"></p><p>ThreadLocal的实现是这样的：每个Thread 维护一个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。</p><p>也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的是图中的虚线，表示 ThreadLocalMap 是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</p><p><img src="/2019/02/13/ThreadLocal/images/pasted-0.png" alt="upload successful"></p><p>ThreadLocalMap由一个个Entry对象构成，Entry的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Entry继承自WeakReference&lt;ThreadLocal&lt;?&gt;&gt;，一个Entry由ThreadLocal对象和Object构成。由此可见，Entry的key是ThreadLocal对象，并且是一个弱引用。当没指向key的强引用后，该key就会被垃圾收集器回收。</p><p>那么，ThreadLocal是如何工作的呢？下面来看set和get方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ThreadLocal为什么会内存泄漏"><a href="#ThreadLocal为什么会内存泄漏" class="headerlink" title="ThreadLocal为什么会内存泄漏"></a>ThreadLocal为什么会内存泄漏</h3><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如线程池线程循环利用)，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。</p><p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。</p><p>但是这些被动的预防措施并不能保证不会内存泄漏：</p><ul><li>使用static的ThreadLocal有外部强引用，延长了ThreadLocal的生命周期，可能导致的内存泄漏</li><li>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。(虽然ThreadLocal回收了但是value没有被回收)</li></ul><h4 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h4><p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p><p>我们先来看看官方文档的说法：</p><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。</p><p>下面我们分两种情况讨论：</p><ul><li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</li></ul><p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><p>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p><p>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。<br>在使用线程池的情况下，thread的生命周期很长的情况下，没有及时清理ThreadLocal，导致内存泄漏随着应用运行的时间越来越长会导致内存溢出。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h3&gt;&lt;p&gt;jdk文档介绍&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="java基础" scheme="http://shiyangtao.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://shiyangtao.github.io/2019/01/29/%E9%93%BE%E8%A1%A8/"/>
    <id>http://shiyangtao.github.io/2019/01/29/链表/</id>
    <published>2019-01-29T05:29:25.000Z</published>
    <updated>2019-02-01T08:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p><h3 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h3><p>为了直观地对比，我画了一张图。从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。<br>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><p><img src="/2019/01/29/链表/images/pasted-0.png" alt="upload successful"></p><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的<strong>“结点”</strong>。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>“后继指针”</strong></p><p><img src="/2019/01/29/链表/images/pasted-1.png" alt="upload successful"><br>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p><img src="/2019/01/29/链表/images/pasted-2.png" alt="upload successful"></p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。<br><img src="/2019/01/29/链表/images/pasted-3.png" alt="upload successful"><br>和单链表相比，<strong>循环列表的优点是</strong>是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。<br><img src="/2019/01/29/链表/images/pasted-4.png" alt="upload successful"><br>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>你可能会说，我刚讲到单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；<br>这种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。</li></ul><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><ul><li>删除给定指针指向的结点。<br>对于这种种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</li></ul><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。你可以参照我刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 Java 语言，你肯定用过 LinkedHashMap 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是<strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="/2019/01/29/链表/images/pasted-5.png" alt="upload successful"></p><h3 id="数组vs链表性能比拼"><a href="#数组vs链表性能比拼" class="headerlink" title="数组vs链表性能比拼"></a>数组vs链表性能比拼</h3><p>通过前面内容的学习，你应该已经知道，数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="/2019/01/29/链表/images/pasted-6.png" alt="upload successful"></p><h3 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h3><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h3 id="链表实现LRU缓存"><a href="#链表实现LRU缓存" class="headerlink" title="链表实现LRU缓存"></a>链表实现LRU缓存</h3><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li>如果次数据不在链表里<ul><li>链表满了，删除尾结点，该数据插入头结点</li><li>链表还有空间，插入头结点</li></ul></li></ol><p><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/link/LinkedLRU.java" target="_blank" rel="noopener">代码地址</a><br>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。因为要涉及我们还没有讲到的数据结构，所以这个优化方案，我现在就不详细说了，等讲到散列表的时候，我会再拿出来讲。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="数组实现LRU缓存"><a href="#数组实现LRU缓存" class="headerlink" title="数组实现LRU缓存"></a>数组实现LRU缓存</h4><p>除了基于链表的实现思路，实际上还可以用数组来实现 LRU 缓存淘汰策略。如何利用数组实现 LRU 缓存淘汰策略呢？我把这个问题留给你思考。<br>我的思路是这样：维护一个数组，越靠近尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从数组第一个元素开始遍历</p><ol><li>如果此数据已经被缓存，我们遍历得到这个数据的下标，并将前面的所有数据都往右移动一位，然后在把该元素放到数据下标0的位置</li><li>如果数组不在数组里<ul><li>数组满了，把最后一个元素之前的元素向右平移一位，最后一个元素自然也就丢弃了，然后把该数据放到下标为0的位置</li><li>数组还有空间，把数组里所有元素向右平移一位，然后把该数据放到下标为0的位置<br><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/array/ArrayLRU.java" target="_blank" rel="noopener">代码地址</a><br>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍数组，所以这种基于数组的实现思路，缓存访问的时间复杂度为 O(n)。</li></ul></li></ol><h4 id="如何判断一个字符串是回文串"><a href="#如何判断一个字符串是回文串" class="headerlink" title="如何判断一个字符串是回文串"></a>如何判断一个字符串是回文串</h4><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的思题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？<br>我的思路是：使用快慢两个指针找到链表中点，慢指针每次前进一步，快指针每次前进两步。在慢指针前进的过程中，同时修改其 next 指针，使得链表前半部分反序。最后比较中点两侧的链表是否相等。<br><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/link/Palindrome.java" target="_blank" rel="noopener">代码地址</a></p><h4 id="常见单链表编程题"><a href="#常见单链表编程题" class="headerlink" title="常见单链表编程题"></a>常见单链表编程题</h4><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序链表合并</li><li>删除倒数第n个代码</li><li>求链表中间结点<br><a href="https://github.com/shiyangtao/leetCode-pratice/blob/master/src/java/link/LinkProblem.java" target="_blank" rel="noopener">代码地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。&lt;/p&gt;
&lt;h3 id=&quot;链表和数组的区别&quot;&gt;&lt;a href=&quot;#链表和数组的区别&quot; 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://shiyangtao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://shiyangtao.github.io/2019/01/29/%E6%95%B0%E7%BB%84/"/>
    <id>http://shiyangtao.github.io/2019/01/29/数组/</id>
    <published>2019-01-29T02:31:00.000Z</published>
    <updated>2019-01-29T03:44:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何实现随机访问"><a href="#如何实现随机访问" class="headerlink" title="如何实现随机访问"></a>如何实现随机访问</h3><p>什么是数组？数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><p>这个定义里有几个关键词</p><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><p>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="/2019/01/29/数组/images/pasted-0.png" alt="upload successful"><br>而与他对立的是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="/2019/01/29/数组/images/pasted-1.png" alt="upload successful"></p><h4 id="连续的内存空间和相同类型的数据"><a href="#连续的内存空间和相同类型的数据" class="headerlink" title="连续的内存空间和相同类型的数据"></a>连续的内存空间和相同类型的数据</h4><p>正是有了这个特性，他才有了随机访问这个“杀手锏”。但是有利就有弊，比如删除添加为了保证连续性，必须要做数据搬移工作。<br>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？<br>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10] 来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><p><img src="/2019/01/29/数组/images/pasted-2.png" alt="upload successful"><br>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure></p><p>其中data_type_size表示每个元素的大小。我们这个例子数组中存储的是int类型数组，所以date_type_size就为4个字节。<br>这里特别纠正一个“错误”。面试中经常会问到数组和链表的区别，很多人都会回答，“链表适合插入、删除、时间复杂度O(1);数组适合查找，查找时间复杂度为O(1)”。<br>实际上，这种表述是不准确的。数组是适合查找操作，但查找时间复杂度不是O(1)。即便是排序好的数组，你用二分查找时间复杂度才是O(logn)。所以正确的表述是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。</p><h3 id="低效的插入和删除"><a href="#低效的插入和删除" class="headerlink" title="低效的插入和删除"></a>低效的插入和删除</h3><p>前面提到，数组为了保证内存数组连续性，会导致插入、删除两个操作会比较低效。</p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>假设数组长度为n，现在，需要把一个数据插入到数组第k个位置。为了把第k个位置腾出来，给新来的数据，我们需要把k～n这部分元素都顺序往后挪一下，那时间复杂度是多少呢？<br>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。<br>如果数组中的数据是有序的，我们在某个位置插入一个新元素，就必须按照刚才的方法搬移k之后的数组。但是如果数组中的数据没有任何规律，数组只是存储集合。在这种情况下，如果把数据插入第k个位置，为了避免大规模搬移，直接将第k个位置的数据插入到数组最后，把新的元素放在第k个位置。如下图所示</p><p><img src="/2019/01/29/数组/images/pasted-3.png" alt="upload successful"><br>利用这个技巧，在特定场景下，在第k个位置插入元素的复杂度就降到了O(1)</p><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>跟插入操作类似，如果删除第k个位置的数据，为了内存连续性，也需要搬移数据，不然会出现空洞，内存就不连续了。<br>和插入类似，如果删除末尾的数据，时间复杂度O(1);如果删除开头的数据，则最坏情况时间复杂度为O(n);平均情况时间复杂度也为O(n)。<br>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？<br>我们继续来看例子。数组 a[10] 中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src="/2019/01/29/数组/images/pasted-4.png" alt="upload successful"><br>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。<br>如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。</p><h3 id="容器能否代替数组？"><a href="#容器能否代替数组？" class="headerlink" title="容器能否代替数组？"></a>容器能否代替数组？</h3><p>针对数组类型，很多语言提供了容器类，比如java中的ArrayList。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？<br>因为我是java开发，几乎每天都在用ArrayList。个人觉得ArrayList的最大优势就是可以把很多数组操作的细节封装起来。比如插入、删除、动态扩容。</p><p>数组本身在定义时需要预先指定大小，因为需要分配连续的内存空间。乳沟我们申请了大小为10的数组，当第11个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后在插入新的数据。</p><p>如果使用ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList已经帮我们实现好了。每次空间不够时，他都会自动扩容为1.5倍大小。</p><p>不过，这里需要注意一点，因为扩容需要内存申请和数据搬移，比较耗时。所以，如果事先能去定需要存储数据的大小，最后在创建ArrayList的时候事先指定数据大小。</p><p>作为高级语言编程者，是不是数组就无用武之地了？当然不是，一下情况可以用数组。</p><ol><li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</li><li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</li><li>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList<arraylist> array。</arraylist></li></ol><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><h3 id="为什么大多数编程语言数组下标要从0开始而不是1"><a href="#为什么大多数编程语言数组下标要从0开始而不是1" class="headerlink" title="为什么大多数编程语言数组下标要从0开始而不是1"></a>为什么大多数编程语言数组下标要从0开始而不是1</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure></p><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure></p><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p>不过我认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。</p><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何实现随机访问&quot;&gt;&lt;a href=&quot;#如何实现随机访问&quot; class=&quot;headerlink&quot; title=&quot;如何实现随机访问&quot;&gt;&lt;/a&gt;如何实现随机访问&lt;/h3&gt;&lt;p&gt;什么是数组？数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://shiyangtao.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://shiyangtao.github.io/2019/01/26/2019-01-28-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://shiyangtao.github.io/2019/01/26/2019-01-28-策略模式/</id>
    <published>2019-01-26T04:19:00.000Z</published>
    <updated>2019-01-28T10:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一版鸭子游戏"><a href="#第一版鸭子游戏" class="headerlink" title="第一版鸭子游戏"></a>第一版鸭子游戏</h4><p>我们设计了一个鸭子游戏项目，游戏中会出现各种鸭子，为此Joe实现了一个超类Duck，让鸭子子类都继承这个类，如下图所示。<br><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-0.png" alt="upload successful"></p><h4 id="加鸭子会飞的需求"><a href="#加鸭子会飞的需求" class="headerlink" title="加鸭子会飞的需求"></a>加鸭子会飞的需求</h4><h5 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h5><p>过了几天主管找到Joe说希望有的鸭子能飞，Joe说so easy，只需在超类里增加一个fly()方法就ok了。<br><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-1.png" alt="upload successful"><br>但是过了几天主管对外演示时发现，橡皮鸭子在屏幕上飞来飞去，非常尴尬。主管打电话开始喷Joe:你可以去看看boss直聘了。<br>Joe忽略了一件事，并非所有鸭子都会飞，他在超类里加上新的行为，会使得不该拥有这个行为的子类也拥有了这个行为。他体会了一件事：当涉及维护时为了复用目的使用继承结局并不完美。</p><p>Joe：那么橡皮鸭子类可以重写这个fly方法里边什么也不做，不就可以了吗？<br>主管：那么所有不能飞的子类都得重写一遍fly，然后如果加入木鸭(不会飞不会叫)，也得把quack()方法重写。<br>Joe意思到继承可能无法解决这个问题：</p><h5 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h5><p>Joe：那么可以把fly()和quack()方法从超类里拆出来，只有能飞/能叫的鸭子子类实现这个接口<br><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-2.png" alt="upload successful"><br>主管：这真是个超级糟糕的设计，如果你认为重写几个方法很差劲，但是48个子类都稍微修改下飞行的行为呢？<br>Joe：我去还真是，虽然Flayable和Quackable能解决一部分问题（不再有会飞的橡皮鸭），但是却造成代码无法复用啊，每个会飞的鸭子子类都得实现一个fly()方法哪怕他们的飞的行为是一样的，如果每个fly方法里增加打印日志得需要改48个子类。那咋办呀？</p><h4 id="设计原则一"><a href="#设计原则一" class="headerlink" title="设计原则一"></a>设计原则一</h4><p>主管：把问题归零把，下面给你介绍一个设计原则：找出应用中可能需要变化的地方，把他们独立出来，不要在和哪些不变的代码混在一起了，把会变化的代码封装起来，好让其他部分不受影响，代码变化引起的bug变少，系统更加有弹性</p><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-3.png" alt="upload successful"><br>下面是这个设计原则的另一种思考方式：“把会变化的部分取出并封装起来，以便以后可以轻易的改动或者扩展此部分，而不影响不需要变化的部分“<br>主管：Joe是时候把鸭子的行为从Duck里行为拆出来了！<br>Joe：ok，那么Duck里的行为除了fly和quack有问题外，其他行为一切还算正常，现在要分开变化部分和不变部分了，我打算建立两组类看图</p><h4 id="设计原则二"><a href="#设计原则二" class="headerlink" title="设计原则二"></a>设计原则二</h4><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-4.png" alt="upload successful"><br>那么如何设计那组实现飞行和呱呱叫的的行为的类呢？我们希望一切能有弹性，毕竟，正是一开始鸭子行为没有弹性，才让我们走上现在这条路。我们还想能够“指定”行为到鸭子的实例。比方说，我们想要产生一个新的绿头鸭的实例，并指定特定的“类型”的飞行行为给它。干脆让鸭子的行为可以动态地改变好了。换句话说，我们应该在鸭子类中包含设定行为的方法，这样就可以在“运行时”动态地“改变”绿头鸭的飞行行为。有了这些目标要实现，接着看看第二个设计原则：</p><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-5.png" alt="upload successful"><br>我们利用接口代表每个行为，比方说，FlyBehavior和QuackBehavior接口。所以这次鸭子类不回负责实现Fly与Quack接口，反而是由我们制造一组其他类专门实现FlyBehavior与QuackBehavior,这些就称为“行为”类。</p><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-7.png" alt="upload successful"><br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。<br>而我们可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。这么一来，有了继承的“复用”的好处，却没有继承所带来的包袱。</p><h4 id="整合鸭子的行为"><a href="#整合鸭子的行为" class="headerlink" title="整合鸭子的行为"></a>整合鸭子的行为</h4><p>关键在于，鸭子现在会将飞行和呱呱叫“委托”(delegate)别人处理，而不是定义在Duck类(或子类)内的呱呱叫和飞行方法。</p><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-8.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="comment">//每只鸭子都会引用实现QuackBehavior接口的对象。</span></span><br><span class="line">QuackBehavior quackBehavior;</span><br><span class="line">    <span class="comment">// 还有更多</span></span><br><span class="line">    .......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//鸭子对象不亲自处理呱呱叫的行为，而是委托给quackBehavior引用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    quckBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-9.png" alt="upload successful"></p><h4 id="设计原则三"><a href="#设计原则三" class="headerlink" title="设计原则三"></a>设计原则三</h4><p>“有一个”可能比“是一个”更好。<br>“有一个”关系相当有趣：每一鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和呱呱叫委托给它们代为处理。<br>当你将两个类结合起来使用，如同本例一般，这就是组合(composition)。这种做法和“继承”不同的地方在于，鸭子的行为不是继承来的，而是和适当的行为对像“组合来的”。这是一个很重要的技巧。其实是使用了我们的第三个设计原则：</p><p><img src="/2019/01/26/2019-01-28-策略模式/images/pasted-10.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一版鸭子游戏&quot;&gt;&lt;a href=&quot;#第一版鸭子游戏&quot; class=&quot;headerlink&quot; title=&quot;第一版鸭子游戏&quot;&gt;&lt;/a&gt;第一版鸭子游戏&lt;/h4&gt;&lt;p&gt;我们设计了一个鸭子游戏项目，游戏中会出现各种鸭子，为此Joe实现了一个超类Duck，让鸭子子类都继承
      
    
    </summary>
    
      <category term="设计模式" scheme="http://shiyangtao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://shiyangtao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://shiyangtao.github.io/2019/01/10/%E9%9D%A2%E8%AF%95/2019-01-10/"/>
    <id>http://shiyangtao.github.io/2019/01/10/面试/2019-01-10/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-26T01:15:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>1.对链表进行归并排序，链表可能有环<br>2.b+树b树的区别，优缺点</p><h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>1.线程池有哪些参数，有哪些作用，如果任务超过核心线程数，会发生什么？<br><a href="https://www.jianshu.com/p/432554383c55" target="_blank" rel="noopener">https://www.jianshu.com/p/432554383c55</a><br>2.hashset  底层实现<br>维护了一个hashMap<br>3.hashmap，hashtable，concurrentHashMap区别和底层原理<br>hashMap线程不安全，hashtable线程安全set/get都加了synchronized，concurrentHashMap线程安全采用锁分段来实现线程安全</p><ul><li>copyOnWriteList<br><a href="http://www.importnew.com/25034.html" target="_blank" rel="noopener">http://www.importnew.com/25034.html</a><br>4.String/StringBuffer/StringBuilder<br>String不可变，每次拼接都会新创建一个String对象<br>StringBuffer线程安全，维护一个数组(默认16)，append超过大小会出发Array copy<br>StringBuilder线程非安全，维护一个数组(默认16)，append超过大小会出发Array copy<br>4.公平锁和非公平锁怎么实现的<br>公平锁代码<br><img src="https://upload-images.jianshu.io/upload_images/2455482-8506c591de4e859a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/2455482-3af4b59db916bd99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>非公平锁代码<br><img src="https://upload-images.jianshu.io/upload_images/2455482-1d8a6c31c4eca12a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/2455482-4fe398d43a0aa5f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>总结：公平锁和非公平锁只有两处不同：</p><p>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p>5.说说java AQS 原理详细介绍下<br>看看java并发编程实战 关于AQS的章节<br>6.实现一个线程安全的计数器<br>AtomicInteger.incrementAndGet<br>7.synchronized和lock的区别</p><p>8.介绍happen-before<br>9.三个线程保证执行顺序<a href="https://www.cnblogs.com/kaleidoscope/p/9877174.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaleidoscope/p/9877174.html</a></p><h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><p>1.java 内存模式</p><p>#数据库<br>1.连接池底层说下</p><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ol><li>解决缓存雪崩和缓存穿透的方案<br><a href="https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug</a>?</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;p&gt;1.对链表进行归并排序，链表可能有环&lt;br&gt;2.b+树b树的区别，优缺点&lt;/p&gt;
&lt;h1 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#jav
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql读写分离</title>
    <link href="http://shiyangtao.github.io/2019/01/05/mysql/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://shiyangtao.github.io/2019/01/05/mysql/mysql读写分离/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-01-29T02:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决问题，读压力，解决不了存储压力<br>读表利用索引提升查询速度，主表可以不建很多索引提升写入速度。</p><h4 id="带来问题"><a href="#带来问题" class="headerlink" title="带来问题"></a>带来问题</h4><ul><li>主从复制延迟<br>例如：注册完账号后，登陆显示无该用户<br>解决方法</li></ul><ol><li>写操作后的读操作指定发给主服务器<br>例如：注册完后，登陆读主库，这种方式和业务强绑定，如果新来的人不知道这样写代码，就会导致一个bug</li><li>读从机失败在去读主机（二次读取）<br>对业务无绑定，只需要对底层数据库访问api进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机读的压力。</li><li>关键业务读写全部指向主机，非关键业务采用读写分离<br>例如：注册登陆业务读写全部访问主机，用户介绍、爱好可以采用读写分离。</li></ol><ul><li>分配机制<br>1.程序代码封装<br>优点实现简单。<br>缺点每个编程语言都要实现一次，如果主从发生切换，则需要所有系统都修改配置并重启<br>目前开源的 淘宝的TDDL<br>2.中间件封装<br>优点支持多种编程语言，主从切换无感知（中间件可探测主从状态，比如发一个写语句，成功的是主）<br>缺点，实现复杂，所有读写请求经过中间件对性能要求高<br>目前开源的 奇虎360 atlas</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决问题，读压力，解决不了存储压力&lt;br&gt;读表利用索引提升查询速度，主表可以不建很多索引提升写入速度。&lt;/p&gt;
&lt;h4 id=&quot;带来问题&quot;&gt;&lt;a href=&quot;#带来问题&quot; class=&quot;headerlink&quot; title=&quot;带来问题&quot;&gt;&lt;/a&gt;带来问题&lt;/h4&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
      <category term="高性能" scheme="http://shiyangtao.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上死锁</title>
    <link href="http://shiyangtao.github.io/2018/12/24/mysql/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%AD%BB%E9%94%81/"/>
    <id>http://shiyangtao.github.io/2018/12/24/mysql/记一次线上死锁/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2019-01-26T01:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目做了什么"><a href="#项目做了什么" class="headerlink" title="项目做了什么"></a>项目做了什么</h3><p>这个项目是为了处理一些任务，实现是启动定时任务去处理这些数据，因为项目上线后是集群的，所以为了避免多个节点处理到相同的数据，我们使用select … where  state =0 for update limit 500 来锁住数据，然后update state =2值。这样其他节点就不会重复处理数据了</p><p>同事定时任务的代码大概是这样的，我这里用伪代码表示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span> <span class="comment">//注意使用for update一定要在事务里边</span></span><br><span class="line">processData()&#123;</span><br><span class="line">bikeIds = findForUpdate();<span class="comment">//select * from test_rawdata where state=0 for update limit 500;</span></span><br><span class="line"><span class="comment">//取出数据，然后先状态改成2</span></span><br><span class="line">updateData(bikeIds);<span class="comment">//update test_rawdata set state = 2 where bikeId in(bikeIds);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了这个地方操作db外，其他地方也有insert delete，所以for update的where条件里必须要有索引，因为如果where 里的字段没有索引的话，for update就不是行锁了，就升级成表锁了。<br>那当处理定时任务时，insert和delete都将会被阻塞，这样并发性太弱了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_rawdata` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;,</span><br><span class="line">  `bikeId` varchar(15) NOT NULL COMMENT &apos;车id&apos;,</span><br><span class="line">  `lat` decimal(11,8) NOT NULL DEFAULT &apos;0.00000000&apos; COMMENT &apos;纬度&apos;,</span><br><span class="line">  `lng` decimal(11,8) NOT NULL DEFAULT &apos;0.00000000&apos; COMMENT &apos;经度&apos;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建更新时间，默认当前时间&apos;,</span><br><span class="line">  `state` int(8) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0表示未处理 1处理中&apos;,</span><br><span class="line">  `accuracy` smallint(6) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;位置精确度&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uniq_bikeid` (`bikeId`),</span><br><span class="line">  KEY `idx_time` (`update_time`) USING BTREE,</span><br><span class="line">  KEY `idx_state` (`state`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=8897633 DEFAULT CHARSET=utf8 COMMENT=&apos;车辆原始位置&apos;;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2455482-a61ae5f452263c18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="db记录"></p><p>trx1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0;</span><br><span class="line">begin;</span><br><span class="line">select * from test_rawdata where state=0 for update;</span><br><span class="line">select sleep(8);</span><br><span class="line">update test_rawdata set state = 2 where bikeId = &quot;7fd9gSBkZ1&quot;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p><p>trx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0;</span><br><span class="line">begin;</span><br><span class="line">delete from test_rawdata where bikeId = &apos;7fd9gSBkZ1&apos;; //在trx sleep时间点执行</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p><p>发生死锁<br>死锁日志<br><img src="https://upload-images.jianshu.io/upload_images/2455482-67be5b7941106602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="https://upload-images.jianshu.io/upload_images/2455482-b4cf0e82040a4632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="https://upload-images.jianshu.io/upload_images/2455482-e874a232cace2f0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接<br>innodb的锁 <a href="https://zhuanlan.zhihu.com/p/31875702" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31875702</a><br>索引和锁 <a href="https://zhuanlan.zhihu.com/p/40396971" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40396971</a><br><a href="https://www.jianshu.com/p/1dc4250c6f6f" target="_blank" rel="noopener">https://www.jianshu.com/p/1dc4250c6f6f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;项目做了什么&quot;&gt;&lt;a href=&quot;#项目做了什么&quot; class=&quot;headerlink&quot; title=&quot;项目做了什么&quot;&gt;&lt;/a&gt;项目做了什么&lt;/h3&gt;&lt;p&gt;这个项目是为了处理一些任务，实现是启动定时任务去处理这些数据，因为项目上线后是集群的，所以为了避免多个节点处
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="http://shiyangtao.github.io/2018/12/08/mysql/mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://shiyangtao.github.io/2018/12/08/mysql/mysql的四种事务隔离级别/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-01-26T01:14:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/huanongying/p/7021555.html" target="_blank" rel="noopener">https://www.cnblogs.com/huanongying/p/7021555.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/huanongying/p/7021555.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/huanongying/p/7021555
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql分库分表</title>
    <link href="http://shiyangtao.github.io/2018/12/05/mysql/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://shiyangtao.github.io/2018/12/05/mysql/mysql分库分表/</id>
    <published>2018-12-04T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="业务分库"><a href="#业务分库" class="headerlink" title="业务分库"></a>业务分库</h4><p>按照业务分库，比如用户、商品、订单分库<br>带来的问题</p><ol><li>join 问题<br>不在同一数据库无法join，只能先查一个数据库拿到id列表，在去另外一个库查询</li><li>事务问题<br>原本在同一个数据库的不同表的操作可以在同一个事务里边，分散到不同数据库后无法通过事务统一修改。</li><li>成本问题</li></ol><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><ol><li>垂直分表<br>把不常用且占用了大量空间的列拆分出去。带了的问题是原来只要查询一次就能获取所有所有列，现在需要查询多次</li><li>水平分表</li></ol><ul><li><p>路由</p><ul><li>范围路由<br>按照userId的范围分表，特点可能分配不均（例如按照1000万分表，可能一个表有1000万另一个表只有1000），随着数据的增加平滑的扩充新表，原数据不动</li><li>hash路由<br>按照hash取模分表，特点分配均匀，但是新增表所有数据需要重新分布，但是使用一致性hash算法可以优化</li><li>配置路由<br>增加一个配置表比如 user_router表 包含 user_id,table_id两列,优点灵活，缺点多查询一次表太大了性能也会不好</li></ul></li><li><p>join<br>需要多次join然后合并</p></li><li>count()<br>多个表count()相加，实现简单去诶单性能较低。增加一个记录数表，性能优化了，但是复杂度增加了，必须要同步记录，但是又不能放在同一事务里处理，因为记录表插入失败不应该回滚业务逻辑</li><li>order by<br>数据分散多个字表中，排序无法在数据库中完成，只能由业务或者中间件去分表查询每个子表中的数据然后汇总。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;业务分库&quot;&gt;&lt;a href=&quot;#业务分库&quot; class=&quot;headerlink&quot; title=&quot;业务分库&quot;&gt;&lt;/a&gt;业务分库&lt;/h4&gt;&lt;p&gt;按照业务分库，比如用户、商品、订单分库&lt;br&gt;带来的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;join 问题&lt;br&gt;不在同一数据库无法
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
      <category term="高性能" scheme="http://shiyangtao.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>shell启动socket</title>
    <link href="http://shiyangtao.github.io/2018/12/03/linux%E5%91%BD%E4%BB%A4/shell%E5%90%AF%E5%8A%A8socket/"/>
    <id>http://shiyangtao.github.io/2018/12/03/linux命令/shell启动socket/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:13:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>nc -l localhost 3000 server<br>nc localhost 3000 client</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nc -l localhost 3000 server&lt;br&gt;nc localhost 3000 client&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://shiyangtao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grep</title>
    <link href="http://shiyangtao.github.io/2018/11/03/linux%E5%91%BD%E4%BB%A4/grep/"/>
    <id>http://shiyangtao.github.io/2018/11/03/linux命令/grep/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>grep 后面带上-A -B -C 参数可以多显示几行内容</p><p>grep -A 5 可以显示匹配内容以及后面的5行内容<br>grep -B 5 可以显示匹配内容以及前面的5行内容<br>grep -C 5 可以显示匹配内容以及前后面的5行内容</p><p>grep “” logfile|wc -l 显示匹配的行数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;grep 后面带上-A -B -C 参数可以多显示几行内容&lt;/p&gt;
&lt;p&gt;grep -A 5 可以显示匹配内容以及后面的5行内容&lt;br&gt;grep -B 5 可以显示匹配内容以及前面的5行内容&lt;br&gt;grep -C 5 可以显示匹配内容以及前后面的5行内容&lt;/p&gt;
&lt;p&gt;gr
      
    
    </summary>
    
    
      <category term="linux" scheme="http://shiyangtao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池构造方法</title>
    <link href="http://shiyangtao.github.io/2018/10/03/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://shiyangtao.github.io/2018/10/03/java并发编程/java线程池/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:11:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的ThreadPoolExecutor类<br>提供了四个构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br><span class="line">    .....</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue);</span><br><span class="line"> </span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</span><br><span class="line"> </span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</span><br><span class="line"> </span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="参数解读"><a href="#参数解读" class="headerlink" title="参数解读"></a>参数解读</h5><ul><li>corePoolSize: 核心线程大小 </li><li>maximumPoolSize: 最大线程数</li><li>workQueue: 一个阻塞队列，用来存储等待执行的任务，由如下选择ArrayBlockingQueue 有界队列;<br>LinkedBlockingQueue 无界队列;<br>SynchronousQueue同步移交，不是一个真正的队列，而是一种在线程中移交的机制。将一个元素放入到队列中必须有一个线程等待接受这个任务，如果没有线程正在等待，且线程池当前大小小于最大值，那么创建一个新的线程去执行，否则根据饱和机制这个任务将被拒绝</li><li>keepAliveTime: 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li>threadFactory：线程工厂，主要用来创建线程；可以自己写个线程工厂来个性化自己的线程比如名字，或者计数</li><li>rejectedExecutionHandler:<br>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务<h5 id="线程创建逻辑ThreadPoolExecutor里execute方法"><a href="#线程创建逻辑ThreadPoolExecutor里execute方法" class="headerlink" title="线程创建逻辑ThreadPoolExecutor里execute方法"></a>线程创建逻辑ThreadPoolExecutor里execute方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    //  “线程数” 的整数</span><br><span class="line">    int c = ctl.get();</span><br><span class="line"></span><br><span class="line">    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        // 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        // 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><span class="line"></span><br><span class="line">    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        /* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         */</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        // 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    // 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>1.如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；<br>2.如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；<br>3.如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略</p><p>Executors里的三个静态方法</p><ul><li>生成固定大小线程池<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p><p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p><ul><li><p>生成只有一个线程的固定线程池，这个更简单，和上面的一样，只要设置线程数为 1 就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。<br>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p><p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line">// corePoolSize 为 0，所以不会进到这个 if 分支</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    if (addWorker(command, true))</span><br><span class="line">        return;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    int recheck = ctl.get();</span><br><span class="line">    if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    else if (workerCountOf(recheck) == 0)</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://javadoop.com/post/java-thread-pool#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">https://javadoop.com/post/java-thread-pool#%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的ThreadPoolExecutor类&lt;br&gt;提供了四个构造方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
    
      <category term="java并发编程" scheme="http://shiyangtao.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式技术栈</title>
    <link href="http://shiyangtao.github.io/2018/09/21/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>http://shiyangtao.github.io/2018/09/21/分布式/分布式技术栈/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2019-01-25T13:48:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。</p><ul><li>大流量处理。通过集群技术把大规模并发请求的负载分散到不同的机器上。</li><li>关键业务保护。提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）。如果流量过大，需要对业务降级，以保护关键业务流转。</li></ul><p>说白了就是干两件事。一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。</p><p>##提高架构的性能<br>咱们先来看看，提高系统性能的常用技术。<img src="https://upload-images.jianshu.io/upload_images/2455482-b2a5188453c5a060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>缓存系统。加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。</p></li><li><p>负载均衡系统，是做水平扩展的关键技术。其可以用多台机器来共同分担一部分流量请求。</p></li><li><p>异步调用。异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。</p></li><li><p>数据分区和数据镜像。数据分区是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而数据镜像是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。</p></li></ul><p>对于一般公司来说，在初期，会使用读写分离的数据镜像方式，而后期会采用分库分表的方式。</p><p>#提高架构的稳定性<br>接下来，咱们来看看提高系统系统稳定性的一些常用技术。<img src="https://upload-images.jianshu.io/upload_images/2455482-b3c90af63f328b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>服务拆分，主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。</p></li><li><p>服务冗余，是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。</p></li><li><p>限流降级。当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。</p></li><li><p>高可用架构，通常来说是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。</p></li><li><p>高可用运维，指的是 DevOps 中的 CI（持续集成）/CD（持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。</p></li></ul><p>上述这些技术非常有技术含量，而且需要投入大量的时间和精力。</p><p>##分布式系统的关键技术<br>而通过上面的分析，我们可以看到，引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决。</p><ul><li><p>服务治理。服务拆分、服务调用、服务发现，服务依赖，服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。</p></li><li><p>架构软件管理。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。</p></li><li><p>DevOps。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。</p></li><li><p>自动化运维。有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。</p></li><li><p>资源调度管理。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。</p></li><li><p>整体架构监控。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。</p></li><li><p>流量控制。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。</p></li></ul><p>此时，你会发现，要做好这么多的技术，或是要具备这么多的能力，简直就是一个门槛，是一个成本巨高无比的技术栈，看着就都头晕。要实现出来得投入多少人力、物力和时间啊。是的，这就是分布式系统中最大的坑。</p><p>不过，我们应该庆幸自己生活在了一个非常不错的年代。今天有一个技术叫——Docker，通过 Docker 以及其衍生出来的 Kubernetes 之类的软件或解决方案，大大地降低了做上面很多事情的门槛。Docker 把软件和其运行的环境打成一个包，然后比较轻量级地启动和运行。在运行过程中，因为软件变成了服务可能会改变现有的环境。但是没关系，当你重新启动一个 Docker 的时候，环境又会变成初始化状态。</p><p>这样一来，我们就可以利用 Docker 的这个特性来把软件在不同的机器上进行部署、调度和管理。如果没有 Docker 或是 Kubernetes，那么你可以认为我们还活在“原始时代”。现在你知道为什么 Docker 这样的容器化虚拟化技术是未来了吧。因为分布式系统已经是完全不可逆转的技术趋势了。</p><p>但是，上面还有很多的技术是 Docker 及其周边技术没有解决的，所以，依然还有很多事情要做。那么，如果是一个一个地去做这些技术的话，就像是我们在撑开一张网里面一个一个的网眼，本质上这是使蛮力的做法。我们希望可以找到系统的“纲”，一把就能张开整张网。那么，这个纲在哪里呢？</p><p>##分布式系统的“纲”<br>总结一下上面讲述的内容，你不难发现，分布式系统有五个关键技术，它们是：</p><ul><li>全栈系统监控；</li><li>服务 / 资源调度；</li><li>流量调度；</li><li>状态 / 数据调度；</li><li>开发和运维的自动化。</li></ul><p>而最后一项——开发和运维的自动化，是需要把前四项都做到了，才有可能实现的。所以，最为关键是下面这四项技术，即应用整体监控、资源和服务调度、状态和数据调度及流量调度，它们是构建分布式系统最最核心的东西。<br><img src="https://upload-images.jianshu.io/upload_images/2455482-2a79e0a16d269d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>后面的文章中，我会一项一项地解析这些关键技术。</p><p>小结<br>回顾一下今天的要点内容。首先，我总结了分布式系统需要干的两件事：一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。然后分别从这两个方面阐释，需要通过哪些技术来实现，并梳理出其中的技术难点及可能会带来的问题。最后，欢迎你分享一下你在解决系统的性能和可用性方面使用到的方法和技巧。</p><p>虽然 Docker 及其衍生出来的 Kubernetes 等软件或解决方案，能极大地降低很多事儿的门槛。但它们没有解决的问题还有很多，需要掌握分布式系统的五大关键技术，从根本上解决问题。后面我将陆续撰写几篇文章一一阐述这几大关键技术，详见文末给出的《分布式系统架构的本质》系列文章的目录。</p><ul><li><a href="https://time.geekbang.org/column/article/1411?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统架构的冰与火</a></li><li><a href="https://time.geekbang.org/column/article/1505?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">从亚马逊的实践，谈分布式系统的难点</a></li><li><a href="https://time.geekbang.org/column/article/1512?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统的技术栈</a></li><li><a href="https://time.geekbang.org/column/article/1513?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统关键技术：全栈监控</a></li><li><a href="https://time.geekbang.org/column/article/1604?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统关键技术：服务调度</a></li><li><a href="https://time.geekbang.org/column/article/1609?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统关键技术：流量与数据调度</a></li><li><a href="https://time.geekbang.org/column/article/1610?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">洞悉 PaaS 平台的本质</a></li><li><a href="https://time.geekbang.org/column/article/2080?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">推荐阅读：分布式系统架构经典资料</a></li><li><a href="https://time.geekbang.org/column/article/2421?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">推荐阅读：分布式数据调度相关论文</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2455482-88afd0b9e2f35b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大流量处理。通过集群技术把大规模并发请求的负载分散到不同的机器上。&lt;/li&gt;
&lt;li&gt;关键业务保护。提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应
      
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="分布式" scheme="http://shiyangtao.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="http://shiyangtao.github.io/2018/09/21/%E9%9D%A2%E8%AF%95/jianli/"/>
    <id>http://shiyangtao.github.io/2018/09/21/面试/jianli/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2019-01-26T10:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><ul><li>史洋涛/男/1990 </li><li>工作年限：4年</li><li>手机（微信）：13621204061</li><li>邮箱：<a href="mailto:yangtao.shi@gmail.com" target="_blank" rel="noopener">yangtao.shi@gmail.com</a></li><li>博客：<a href="http://shiyangtao.github.io">http://shiyangtao.github.io</a></li></ul><hr><h2 id="自我描述"><a href="#自我描述" class="headerlink" title="自我描述"></a>自我描述</h2><ul><li>4年＋java开发经验</li><li>极客，热爱编程，喜欢专研</li><li>渴求自我提升、实现价值</li><li>工作认真，积极性高，思路清晰，善于思考，能独立分析和解决问题</li><li>责任心强，具有较强的沟通能力及团队合作精神和承受压力能力。</li></ul><hr><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p> 2010.9-2014.7   石家庄学院             软件工程           本科（统招）   </p><hr><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="北京安信创富科技有限公司-（-2015-09-至今-）-后端团队leader"><a href="#北京安信创富科技有限公司-（-2015-09-至今-）-后端团队leader" class="headerlink" title="北京安信创富科技有限公司             （ 2015.09 - 至今 ）                              后端团队leader"></a>北京安信创富科技有限公司             （ 2015.09 - 至今 ）                              后端团队leader</h3><p>负责把产品的需求转化为规范的开发计划，并对产品需求进行合理化建议，按计划确保开发工作顺利进行。带三至四人后端团队开发、任务分配，并且主导系统全局分析设计和实施，包括接口的设计，数据库设计，第三方服务接入，根据业务来选择实施落地的技术，最后按质按量的完成项目需求。后期根据业务增长针对性的做优化，比如缓存系统，负载均衡，服务拆分，异步调用削峰，数据分区等，来提高架构的性能和稳定性</p><h4 id="客慧来-收银系统（2016-05-至今）"><a href="#客慧来-收银系统（2016-05-至今）" class="headerlink" title="客慧来-收银系统（2016.05-至今）"></a>客慧来-收银系统（2016.05-至今）</h4><p>基于python-libcef开发的windows桌面收银和云端java结合的智能收银系统, 主要为商家提供除基础收银功能外的智能买单，灵活的营销体系、强大的会员系统、营业手机监控等功能，截止目前有1000+商家把传统收银软件替换成我们的收银系统，更加智能和易用</p><ul><li>负责：<br>收银本地和云端产品的接口和数据库的设计，主要模块支付体系、会员体系、营销体系、第三方对接等的开发和功能点的任务分配，根据后期数据增长，需求变化对系统实现功能扩展，服务拆分、性能优化、日志监控、安全性升级等，使系统高性能、高稳定性、安全性。  </li><li><p>解决的问题：</p><ul><li>客户端数据库：选用sqlite数据库，并使用sqlcipher加密，使用SQLAlchemy作为orm框架来提高开发速度，实现数据库版本控制，数据备份</li><li>支付系统：微信支付／支付宝支付／第三方支付（beecloud）的对接，支持多种支付场景（刷卡，扫码，混合），根据商户的各种情况一键切换</li><li>小程序工具开发：小程序和公众号用户关联，合并用户，历史数据刷新</li><li>会员系统优化：按业务拆分数据库，消息队列(SQS)削峰提高性能，实现用户行为收集高并发</li><li>爬取第三方数据：随着对接商家的增多，有会员迁移的需求，有些商家之前使用的平台不支持导出数据，Python Scrapy爬取会员数据</li><li>集群化：服务拆分、RPC调用、容器化（Docker Swarm）、日志收集与监控(Amazon CloudWatch)<h4 id="口碑isv（2017-02-至今）"><a href="#口碑isv（2017-02-至今）" class="headerlink" title="口碑isv（2017.02-至今）"></a>口碑isv（2017.02-至今）</h4>该项目是一个基于支付宝平台，为商家提供便捷支付和营销功能，打通商家收银系统，提供更加支付体验，相比口碑同期ISV，我们终端设备插件可实时配置与打通，并且打通速度快，支持设备广，目前仍有2000+家在使用，曾被口碑平台推荐</li></ul></li><li><p>负责模块：<br>对接口碑功能、商户收银的打通、后期业务增长系统优化、服务拆分、服务冗余</p></li><li>解决的问题：<ul><li>口碑券状态不同步的问题：采取定时通过口碑提供的接口去同步状态，还有给用户发券失败的错误信息异步分析，如果是因为发送已下架的券，就会主动去把状态修改掉</li><li>并发发券提升用户体验：启用多线程去发券，前后端协调一起优化用户体验</li><li>结账前优惠计算问题：团队通过多种测试用例来推算口碑券核销的优先级互斥性，并且记录着给用户发放的券，来实现这个需求。虽然这种方式是有误差的，但是灰度上线经运行一段时间后根据log分析准确率很高，用户体验得到了提升，得到了商户的认可</li><li>收银软件打通：采用数据库打通机制解决，破解商户收银的数据库，云端和本地client通过websocket通信，本地插件把云端指令集翻译成sql语句通过odbc 去查询商家收银数据库，来获得菜品／桌台／订单数据，保证稳定性和准确性</li><li>秒付性能问题：根据后期业务增长，和口碑对isv的高性能和稳定性要求，都使用redis缓存起来常用的查询数据，并且实现服务拆分（重用服务模块），服务冗余（避免单点故障），消息队列削峰（SQS）使用docker 技术实现服务的弹性伸缩，最后通过口碑压测，峰值能达到1000+qps<br>###准成品电商平台  （2015.09-2016.08 ）<br>该项目是一个基于微信平台的一个电商项目，主要向用户出售半成品，项目主要包括：用户登录、用户储值、下单、客服系统、订单消息系统(对商家、对用户)、快递配送系统、后台库存系统、邮件系统，项目截止前，北京有数家半成品供应商，个人消费者10000+，合作小商户等多达1000+，配送基本覆盖了北京全范围</li></ul></li><li>负责模块：<br>用户登陆，微信授权、下单、订单超时、订单配送、拆单、跳单逻辑、库存管理、报表数据等主要模块</li><li>遇到的问题：<ul><li>库存管理：供应商有后台来编辑某个菜品的库存量，库存不足时菜品不能下单，为了避免多人同时下单操作单个菜品的时，引起的并发问题，采用redis的transaction机制，避免高并发引起的库存数量错误问题</li><li>订单数量多后数据库压力：分库分表（Sharding-JDBC）</li></ul></li></ul><h3 id="北京源讯信息技术中国有限公司（2014-10-2015-09-）-java开发工程师"><a href="#北京源讯信息技术中国有限公司（2014-10-2015-09-）-java开发工程师" class="headerlink" title="北京源讯信息技术中国有限公司（2014.10 - 2015.09 ）                 java开发工程师"></a>北京源讯信息技术中国有限公司（2014.10 - 2015.09 ）                 java开发工程师</h3><p>负责公司主要项目维护和个性化开发，性能优化，针对客户反馈出来的问题进行有效的沟通，并解决问题</p><h3 id="北京东方飞扬科技有限公司（2013-12-2014-09-）-java开发工程师"><a href="#北京东方飞扬科技有限公司（2013-12-2014-09-）-java开发工程师" class="headerlink" title="北京东方飞扬科技有限公司（2013.12 - 2014.09 ）                java开发工程师"></a>北京东方飞扬科技有限公司（2013.12 - 2014.09 ）                java开发工程师</h3><p>负责公司定制化项目的敏捷开发，参与总体需求分析与架构设计、领域模型设计、数据库设计、SSH架构搭建及JBPM</p><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><ul><li>java基础扎实，熟悉Jvm，有jvm调优经验</li><li>能够熟练的应用各种框架spring struts hibernate spring Ibatis jpa</li><li>熟悉mysql等关系型数据库，以及数据库调优、sql优化，熟练掌握sql语言</li><li>熟悉redis，mogodb，dynamodb等非关系型数据库</li><li>熟悉Linux操作系统，会使用常用的linux命令，有linux服务器的部署经验</li><li>熟悉docker容器技术，docker编排工具</li><li>熟悉python语言，用于日常脚本和爬虫</li><li>熟悉消息队列 掌握rabbitmq、sqs等消息队列</li><li>熟悉分布式、缓存、消息、异步等机制</li><li>熟悉aws云平台，dynamodb，s3，sqs模块发</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;个人简介&quot;&gt;&lt;a href=&quot;#个人简介&quot; class=&quot;headerlink&quot; title=&quot;个人简介&quot;&gt;&lt;/a&gt;个人简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;史洋涛/男/1990 &lt;/li&gt;
&lt;li&gt;工作年限：4年&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>面试计数器相关</title>
    <link href="http://shiyangtao.github.io/2018/05/20/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://shiyangtao.github.io/2018/05/20/面试/面试-计数器相关/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试官问："><a href="#面试官问：" class="headerlink" title="面试官问："></a>面试官问：</h4><p>文件里有m个身份证号，统计每个身份证号出现的次数</p><h4 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h4><p>使用hashMap实现，key作为身份证号<br><em>ContainsKey</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; freq = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">    int count = freq.containsKey(word) ? freq.get(word) : 0;</span><br><span class="line">    freq.put(word, count + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="面试官问：-1"><a href="#面试官问：-1" class="headerlink" title="面试官问："></a>面试官问：</h4><p>还能优化吗</p><h4 id="回答：-1"><a href="#回答：-1" class="headerlink" title="回答："></a>回答：</h4><p><em>TestForNull</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; freq = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">  Integer count = freq.get(word);</span><br><span class="line">  if (count == null) &#123;</span><br><span class="line">      freq.put(word, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    freq.put(word, count + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>减少调用containsKey方法的开销</p><h4 id="面试官问：-2"><a href="#面试官问：-2" class="headerlink" title="面试官问："></a>面试官问：</h4><p>如果是高并发情况呢</p><h4 id="回答：-2"><a href="#回答：-2" class="headerlink" title="回答："></a>回答：</h4><p>采用ConcurrentHashMap去做，线程安全的</p><h4 id="面试官问：-3"><a href="#面试官问：-3" class="headerlink" title="面试官问："></a>面试官问：</h4><p>高并发下HashMap有什么问题吗</p><h4 id="回答：-3"><a href="#回答：-3" class="headerlink" title="回答："></a>回答：</h4><p>并发情况下使用HashMap造成Race Condition，从而导致死循环，CPU占用率会达到100%<br><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">博文链接hashMap死循环</a></p><h4 id="面试官问：-4"><a href="#面试官问：-4" class="headerlink" title="面试官问："></a>面试官问：</h4><p>ok 用ConcurrentHashMap 实现下</p><h4 id="回答：-4"><a href="#回答：-4" class="headerlink" title="回答："></a>回答：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap &lt;String, Integer&gt; freq = new ConcurrentHashMap &lt;String, Integer&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">  Integer count = freq.get(word);</span><br><span class="line">  if (count == null) &#123;</span><br><span class="line">      freq.put(word, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      freq.put(word, count + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试官问：-5"><a href="#面试官问：-5" class="headerlink" title="面试官问："></a>面试官问：</h4><p>确定能实现？</p><h4 id="回答：-5"><a href="#回答：-5" class="headerlink" title="回答："></a>回答：</h4><p>实现不了 put操作会覆盖，比如两个线程同时进来读到了都是4，那么都会put 5进去，<br>可以给方法加上synchronized锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap &lt;String, Integer&gt; freq = new ConcurrentHashMap &lt;String, Integer&gt;();</span><br><span class="line">public synchronized void incr (String word)&#123;</span><br><span class="line">  Integer count = freq.get(word);</span><br><span class="line">  if (count == null) &#123;</span><br><span class="line">      freq.put(word, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      freq.put(word, count + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="面试官问：-6"><a href="#面试官问：-6" class="headerlink" title="面试官问："></a>面试官问：</h4><p>嗯嗯 加锁确实能实现，但是性能差点，能优化下吗</p><h4 id="回答-当时回答的不好-："><a href="#回答-当时回答的不好-：" class="headerlink" title="回答(当时回答的不好)："></a>回答(当时回答的不好)：</h4><p>能,采用cas方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, AtomicLong&gt; map = new ConcurrentHashMap&lt;String, AtomicLong&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">  map.putIfAbsent(word, new AtomicLong(0));</span><br><span class="line">  map.get(word).incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以采用  AtomicLongMap，AtomicLongMap是Google Guava项目的一个类，它是线程安全、支持并发访问的，通过CAS方式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicLongMap&lt;String&gt; map = AtomicLongMap.create();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">   map.getAndIncrement(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h4><p>AtomicLong – 这组类使用CAS（比较并交换）处理器指令来更新计数器的值。听起来不错，真的是这样吗？是也不是。好的一面是它通过一个直接机器码指令设置值时，能够最小程度地影响其他线程的执行。坏的一面是如果它在与其他线程竞争设置值时失败了，它不得不再次尝试。在高竞争下，这将转化为一个自旋锁，线程不得不持续尝试设置值，无限循环直到成功。这可不是我们想要的方法。<a href="http://www.importnew.com/11345.html" target="_blank" rel="noopener">让我们进入Java 8的LongAdders</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试官问：&quot;&gt;&lt;a href=&quot;#面试官问：&quot; class=&quot;headerlink&quot; title=&quot;面试官问：&quot;&gt;&lt;/a&gt;面试官问：&lt;/h4&gt;&lt;p&gt;文件里有m个身份证号，统计每个身份证号出现的次数&lt;/p&gt;
&lt;h4 id=&quot;回答：&quot;&gt;&lt;a href=&quot;#回答：&quot; c
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>必要商城面试</title>
    <link href="http://shiyangtao.github.io/2018/05/13/%E9%9D%A2%E8%AF%95/%E5%BF%85%E8%A6%81%E5%95%86%E5%9F%8E%E9%9D%A2%E8%AF%95/"/>
    <id>http://shiyangtao.github.io/2018/05/13/面试/必要商城面试/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>无笔试<br>第一轮</p><ul><li>你看过哪些java源码 或者框架的源码</li><li>项目里用了多线程的地方 线程池相关</li><li>数据库隔离</li><li>spring 原理 ioc aop</li><li>自己设计一个券系统，并画出er图</li><li>根据用户的优惠券，快速算出最佳优惠的策略</li></ul><p>第二轮</p><ul><li>业务数据量大，如何优化</li><li>订单超时过期实现（回答延迟mq、redis过期key订阅、Linux定时任务，面试官感觉mq会出现死信，redis或linux会down 有没有更好的方案，没有get到他想考察的点</li></ul><p>第三轮</p><ul><li>依赖第三方服务，比如支付结果的轮询，如果第三方down掉，支付服务会down或者重启后又down是什么原因（考察http 链接的开销，设置过期时间）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无笔试&lt;br&gt;第一轮&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你看过哪些java源码 或者框架的源码&lt;/li&gt;
&lt;li&gt;项目里用了多线程的地方 线程池相关&lt;/li&gt;
&lt;li&gt;数据库隔离&lt;/li&gt;
&lt;li&gt;spring 原理 ioc aop&lt;/li&gt;
&lt;li&gt;自己设计一个券系统，并画出er
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>boss直聘面试15分钟gg</title>
    <link href="http://shiyangtao.github.io/2018/05/03/%E9%9D%A2%E8%AF%95/boss%E7%9B%B4%E8%81%98%E9%9D%A2%E8%AF%9515%E5%88%86gg/"/>
    <id>http://shiyangtao.github.io/2018/05/03/面试/boss直聘面试15分gg/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>#笔试题</p><ul><li>hashmap遍历</li><li>linux log 查处访问前十的IP地址</li><li>三个远程方法a b c 返回类型一样 有一个方法执行完就返回<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1>讲讲hashmap hashmap的几种构造方法<br>讲讲一致性hash算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#笔试题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hashmap遍历&lt;/li&gt;
&lt;li&gt;linux log 查处访问前十的IP地址&lt;/li&gt;
&lt;li&gt;三个远程方法a b c 返回类型一样 有一个方法执行完就返回&lt;h1 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>运行时栈帧结构</title>
    <link href="http://shiyangtao.github.io/2018/03/24/jvm/2018-03-24-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
    <id>http://shiyangtao.github.io/2018/03/24/jvm/2018-03-24-运行时栈帧结构/</id>
    <published>2018-03-23T16:00:00.000Z</published>
    <updated>2019-01-25T13:32:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2455482-1d40e2c7f2f7dc6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈帧概念结构"><br><a id="more"></a><br>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（CurrentStackFrame），与这个栈帧相关联的方法称为当前方法（CurrentMethod）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如上图所示。</p><ul><li><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2>局部变量表用于存放方法参数和方法内定义的局部变量，在java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中明确了该方法所需要分配的局部变量表的最大容量。</li></ul><p>局部变量表的容量以变量槽（VariableSlot，下称Slot）为最小单位，一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型。前面6种不需要多加解释，读者可以按照Java语言中对应数据类型的概念去理解它们，而第7种reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但一般来说，虚拟机实现至少都应当能通过这个引用做到两点，一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束。</p><p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字”this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p><p>为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接影响到系统的垃圾收集行为，请看代码演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">  System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行java -verbose:gc SlotTest</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[GC (System.gc())  <span class="number">66867</span>K-&gt;<span class="number">66040</span>K(<span class="number">125952</span>K), <span class="number">0.0164932</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  66040K-&gt;65813<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, 0.0103833 secs]</span></span><br></pre></td></tr></table></figure></p><p>代码很简单，即向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上”-verbose:gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收这64MB的内存，没有回收placeholder所占的内存能说得过去，因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自然不敢回收placeholder的内存。那我们把代码修改一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">   System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[GC (System.gc())  <span class="number">66867</span>K-&gt;<span class="number">65992</span>K(<span class="number">125952</span>K), <span class="number">0.0054315</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  65992K-&gt;65813<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, 0.0111123 secs]</span></span><br></pre></td></tr></table></figure></p><p>加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现运行结果如下，还是有64MB的内存没有被回收，这又是为什么呢？在解释为什么之前，我们先对这段代码进行第二次修改，在调用System.gc()之前加入一行”int a=0；”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[GC (System.gc())  <span class="number">66867</span>K-&gt;<span class="number">66008</span>K(<span class="number">125952</span>K), <span class="number">0.0024539</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  66008K-&gt;277<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, 0.0105643 secs]</span></span><br></pre></td></tr></table></figure></p><p>这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了。<br>placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GCRoots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p><p>代码示例说明了赋null值的操作在某些情况下确实是有用的，但笔者的观点是不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因有两点，从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法，更关键的是，从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行概念模型的理解之上的。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GCRoots的枚举也与解释执行时期有巨大差别，以前面例子来看，第二个块代码清单在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须加一句”int a = 0;”</p><p>关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量（static修饰）那样存在“准备阶段”。通过前面类加载的讲解，我们已经知道类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值。如下面代码所示，这段代码其实并不能运行，还好编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。<br><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/2455482-c5e6450e37f66dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2>操作数栈（OperandStack）也常称为操作栈，它是一个后入先出（LastInFirstOut,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</li></ul><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><p>举个例子，整数加法的字节码指令iadd<a href="将栈顶两int型数值相加并将结果压入栈顶">^1</a>在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。</p><p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递，重叠的过程如图所示。<br><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/2455482-50160ad6889113c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个栈帧之间的数据共享"></p><ul><li><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</li><li><h2 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h2>当一个方法开始执行后，只有两种方式可以退出这个方法。</li></ul><p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p><p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p><p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2455482-1d40e2c7f2f7dc6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;栈帧概念结构&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>强-软-弱-虚引用</title>
    <link href="http://shiyangtao.github.io/2017/09/21/jvm/%E5%BC%BA-%E8%BD%AF-%E5%BC%B1-%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://shiyangtao.github.io/2017/09/21/jvm/强-软-弱-虚引用/</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2019-01-25T13:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p><p>1 强引用</p><p>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p><p>2 软引用</p><p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p><p>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>3 弱引用</p><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>应用场景：弱应用同样可用于内存敏感的缓存。</p><p>4 虚引用</p><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue);<br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p><p>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。<br>看下边两个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.*;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;VeryBig&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;VeryBig&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Reference&lt;? extends VeryBig&gt; ref = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((ref = rq.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"In queue: "</span>+ ((VeryBigWeakReference) (ref)).id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeWeakToStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">Object o = <span class="keyword">null</span>;</span><br><span class="line">LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = <span class="keyword">new</span> LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">VeryBigWeakReference veryBigWeakReference = <span class="keyword">new</span> VeryBigWeakReference(<span class="keyword">new</span> VeryBig(<span class="string">"Weak "</span> + i), rq);</span><br><span class="line">weakList.add(veryBigWeakReference);</span><br><span class="line">System.out.println(<span class="string">"Just created weak: "</span> + weakList.getLast()+<span class="string">" Reference: "</span>+veryBigWeakReference.get());</span><br><span class="line">o = veryBigWeakReference.get();<span class="comment">// 把weak 改成strong 最后这个没有被回收</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.gc(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 下面休息几分钟，让上面的垃圾回收线程运行完成</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkQueue();</span><br><span class="line">System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recycleWeakTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = <span class="keyword">new</span> LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">VeryBigWeakReference veryBigWeakReference = <span class="keyword">new</span> VeryBigWeakReference(<span class="keyword">new</span> VeryBig(<span class="string">"Weak "</span> + i), rq);</span><br><span class="line">weakList.add(veryBigWeakReference);</span><br><span class="line">System.out.println(<span class="string">"Just created weak: "</span> + weakList.getLast()+<span class="string">" Reference: "</span>+veryBigWeakReference.get());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.gc(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 下面休息几分钟，让上面的垃圾回收线程运行完成</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recycleSoftTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; weakList = <span class="keyword">new</span> LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">VeryBigSoftReference veryBigSoftReference = <span class="keyword">new</span> VeryBigSoftReference(<span class="keyword">new</span> VeryBig(<span class="string">"Weak "</span> + i), rq);</span><br><span class="line">weakList.add(veryBigSoftReference);</span><br><span class="line">System.out.println(<span class="string">"Just created weak: "</span> + weakList.getLast()+<span class="string">" Reference: "</span>+veryBigSoftReference.get());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.gc(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 下面休息几分钟，让上面的垃圾回收线程运行完成</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">changeWeakToStrong();<span class="comment">// 弱引用转化成强引用躲过一劫</span></span><br><span class="line"><span class="comment">// recycleWeakTest(); //触发垃圾回收，被扫描到立马会被回收</span></span><br><span class="line"><span class="comment">// recycleSoftTest();// 只有堆内存不够时才会被回收</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBig</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String id;</span><br><span class="line"><span class="comment">// 占用空间,让线程进行回收</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VeryBig</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Finalizing VeryBig "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBigWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">VeryBig</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VeryBigWeakReference</span><span class="params">(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(big, rq);</span><br><span class="line"><span class="keyword">this</span>.id = big.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBigSoftReference</span> <span class="keyword">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">VeryBig</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VeryBigSoftReference</span><span class="params">(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(big, rq);</span><br><span class="line"><span class="keyword">this</span>.id = big.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strongReferenceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            </span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M], value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map.size-&gt;"</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakReferenceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                WeakReference&lt;<span class="keyword">byte</span>[]&gt; k;</span><br><span class="line">                <span class="keyword">while</span>((k = (WeakReference) rq.remove()) != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">"回收了:"</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(bytes, rq);</span><br><span class="line">            map.put(weakReference, value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map.size-&gt;"</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softReferenceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                SoftReference&lt;<span class="keyword">byte</span>[]&gt; k;</span><br><span class="line">                <span class="keyword">while</span>((k = (SoftReference) rq.remove()) != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">"回收了:"</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(bytes, rq);</span><br><span class="line">            map.put(softReference, value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map.size-&gt;"</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// strongReferenceTest(); //out of mermory</span></span><br><span class="line">        <span class="comment">// softReferenceTest(); // 堆内存不够时会回收</span></span><br><span class="line">        weakReferenceTest();<span class="comment">// 垃圾回收扫描到立马会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。&lt;/p&gt;
&lt;p&gt;1 强引用&lt;/p&gt;
&lt;p&gt;特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创
      
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
</feed>
