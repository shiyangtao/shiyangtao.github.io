<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shiyangtao&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shiyangtao.github.io/"/>
  <updated>2019-01-28T10:42:48.423Z</updated>
  <id>http://shiyangtao.github.io/</id>
  
  <author>
    <name>sytao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>策略模式</title>
    <link href="http://shiyangtao.github.io/2019/01/26/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://shiyangtao.github.io/2019/01/26/策略模式/</id>
    <published>2019-01-26T04:19:00.000Z</published>
    <updated>2019-01-28T10:42:48.423Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第一版鸭子游戏"><a href="#第一版鸭子游戏" class="headerlink" title="第一版鸭子游戏"></a>第一版鸭子游戏</h4><p>我们设计了一个鸭子游戏项目，游戏中会出现各种鸭子，为此Joe实现了一个超类Duck，让鸭子子类都继承这个类，如下图所示。<br><img src="/2019/01/26/策略模式/images/pasted-0.png" alt="upload successful"></p><h4 id="加鸭子会飞的需求"><a href="#加鸭子会飞的需求" class="headerlink" title="加鸭子会飞的需求"></a>加鸭子会飞的需求</h4><h5 id="使用继承"><a href="#使用继承" class="headerlink" title="使用继承"></a>使用继承</h5><p>过了几天主管找到Joe说希望有的鸭子能飞，Joe说so easy，只需在超类里增加一个fly()方法就ok了。<br><img src="/2019/01/26/策略模式/images/pasted-1.png" alt="upload successful"><br>但是过了几天主管对外演示时发现，橡皮鸭子在屏幕上飞来飞去，非常尴尬。主管打电话开始喷Joe:你可以去看看boss直聘了。<br>Joe忽略了一件事，并非所有鸭子都会飞，他在超类里加上新的行为，会使得不该拥有这个行为的子类也拥有了这个行为。他体会了一件事：当涉及维护时为了复用目的使用继承结局并不完美。</p><p>Joe：那么橡皮鸭子类可以重写这个fly方法里边什么也不做，不就可以了吗？<br>主管：那么所有不能飞的子类都得重写一遍fly，然后如果加入木鸭(不会飞不会叫)，也得把quack()方法重写。<br>Joe意思到继承可能无法解决这个问题：</p><h5 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h5><p>Joe：那么可以把fly()和quack()方法从超类里拆出来，只有能飞/能叫的鸭子子类实现这个接口<br><img src="/2019/01/26/策略模式/images/pasted-2.png" alt="upload successful"><br>主管：这真是个超级糟糕的设计，如果你认为重写几个方法很差劲，但是48个子类都稍微修改下飞行的行为呢？<br>Joe：我去还真是，虽然Flayable和Quackable能解决一部分问题（不再有会飞的橡皮鸭），但是却造成代码无法复用啊，每个会飞的鸭子子类都得实现一个fly()方法哪怕他们的飞的行为是一样的，如果每个fly方法里增加打印日志得需要改48个子类。那咋办呀？</p><h4 id="设计原则一"><a href="#设计原则一" class="headerlink" title="设计原则一"></a>设计原则一</h4><p>主管：把问题归零把，下面给你介绍一个设计原则：找出应用中可能需要变化的地方，把他们独立出来，不要在和哪些不变的代码混在一起了，把会变化的代码封装起来，好让其他部分不受影响，代码变化引起的bug变少，系统更加有弹性</p><p><img src="/2019/01/26/策略模式/images/pasted-3.png" alt="upload successful"><br>下面是这个设计原则的另一种思考方式：“把会变化的部分取出并封装起来，以便以后可以轻易的改动或者扩展此部分，而不影响不需要变化的部分“<br>主管：Joe是时候把鸭子的行为从Duck里行为拆出来了！<br>Joe：ok，那么Duck里的行为除了fly和quack有问题外，其他行为一切还算正常，现在要分开变化部分和不变部分了，我打算建立两组类看图</p><h4 id="设计原则二"><a href="#设计原则二" class="headerlink" title="设计原则二"></a>设计原则二</h4><p><img src="/2019/01/26/策略模式/images/pasted-4.png" alt="upload successful"><br>那么如何设计那组实现飞行和呱呱叫的的行为的类呢？我们希望一切能有弹性，毕竟，正是一开始鸭子行为没有弹性，才让我们走上现在这条路。我们还想能够“指定”行为到鸭子的实例。比方说，我们想要产生一个新的绿头鸭的实例，并指定特定的“类型”的飞行行为给它。干脆让鸭子的行为可以动态地改变好了。换句话说，我们应该在鸭子类中包含设定行为的方法，这样就可以在“运行时”动态地“改变”绿头鸭的飞行行为。有了这些目标要实现，接着看看第二个设计原则：</p><p><img src="/2019/01/26/策略模式/images/pasted-5.png" alt="upload successful"><br>我们利用接口代表每个行为，比方说，FlyBehavior和QuackBehavior接口。所以这次鸭子类不回负责实现Fly与Quack接口，反而是由我们制造一组其他类专门实现FlyBehavior与QuackBehavior,这些就称为“行为”类。</p><p><img src="/2019/01/26/策略模式/images/pasted-7.png" alt="upload successful"><br>这样的设计，可以让飞行和呱呱叫的动作被其他的对象复用，因为这些行为已经与鸭子类无关了。<br>而我们可以新增一些行为，不会影响到既有的行为类，也不会影响“使用”到飞行行为的鸭子类。这么一来，有了继承的“复用”的好处，却没有继承所带来的包袱。</p><h4 id="整合鸭子的行为"><a href="#整合鸭子的行为" class="headerlink" title="整合鸭子的行为"></a>整合鸭子的行为</h4><p>关键在于，鸭子现在会将飞行和呱呱叫“委托”(delegate)别人处理，而不是定义在Duck类(或子类)内的呱呱叫和飞行方法。</p><p><img src="/2019/01/26/策略模式/images/pasted-8.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"><span class="comment">//每只鸭子都会引用实现QuackBehavior接口的对象。</span></span><br><span class="line">QuackBehavior quackBehavior;</span><br><span class="line">    <span class="comment">// 还有更多</span></span><br><span class="line">    .......</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//鸭子对象不亲自处理呱呱叫的行为，而是委托给quackBehavior引用的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    quckBehavior.quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>uml图</p><p><img src="/2019/01/26/策略模式/images/pasted-9.png" alt="upload successful"></p><h4 id="设计原则三"><a href="#设计原则三" class="headerlink" title="设计原则三"></a>设计原则三</h4><p>“有一个”可能比“是一个”更好。<br>“有一个”关系相当有趣：每一鸭子都有一个FlyBehavior和一个QuackBehavior，好将飞行和呱呱叫委托给它们代为处理。<br>当你将两个类结合起来使用，如同本例一般，这就是组合(composition)。这种做法和“继承”不同的地方在于，鸭子的行为不是继承来的，而是和适当的行为对像“组合来的”。这是一个很重要的技巧。其实是使用了我们的第三个设计原则：</p><p><img src="/2019/01/26/策略模式/images/pasted-10.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;第一版鸭子游戏&quot;&gt;&lt;a href=&quot;#第一版鸭子游戏&quot; class=&quot;headerlink&quot; title=&quot;第一版鸭子游戏&quot;&gt;&lt;/a&gt;第一版鸭子游戏&lt;/h4&gt;&lt;p&gt;我们设计了一个鸭子游戏项目，游戏中会出现各种鸭子，为此Joe实现了一个超类Duck，让鸭子子类都继承
      
    
    </summary>
    
      <category term="设计模式" scheme="http://shiyangtao.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://shiyangtao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://shiyangtao.github.io/2019/01/10/%E9%9D%A2%E8%AF%95-2019-01-10/"/>
    <id>http://shiyangtao.github.io/2019/01/10/面试-2019-01-10/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-26T01:15:48.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>1.对链表进行归并排序，链表可能有环<br>2.b+树b树的区别，优缺点</p><h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><p>1.线程池有哪些参数，有哪些作用，如果任务超过核心线程数，会发生什么？<br><a href="https://www.jianshu.com/p/432554383c55" target="_blank" rel="noopener">https://www.jianshu.com/p/432554383c55</a><br>2.hashset  底层实现<br>维护了一个hashMap<br>3.hashmap，hashtable，concurrentHashMap区别和底层原理<br>hashMap线程不安全，hashtable线程安全set/get都加了synchronized，concurrentHashMap线程安全采用锁分段来实现线程安全</p><ul><li>copyOnWriteList<br><a href="http://www.importnew.com/25034.html" target="_blank" rel="noopener">http://www.importnew.com/25034.html</a><br>4.String/StringBuffer/StringBuilder<br>String不可变，每次拼接都会新创建一个String对象<br>StringBuffer线程安全，维护一个数组(默认16)，append超过大小会出发Array copy<br>StringBuilder线程非安全，维护一个数组(默认16)，append超过大小会出发Array copy<br>4.公平锁和非公平锁怎么实现的<br>公平锁代码<br><img src="https://upload-images.jianshu.io/upload_images/2455482-8506c591de4e859a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/2455482-3af4b59db916bd99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>非公平锁代码<br><img src="https://upload-images.jianshu.io/upload_images/2455482-1d8a6c31c4eca12a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/2455482-4fe398d43a0aa5f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>总结：公平锁和非公平锁只有两处不同：</p><p>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。<br>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。<br>公平锁和非公平锁就这两点区别，如果这两次 CAS 都不成功，那么后面非公平锁和公平锁是一样的，都要进入到阻塞队列等待唤醒。</p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><p>5.说说java AQS 原理详细介绍下<br>看看java并发编程实战 关于AQS的章节<br>6.实现一个线程安全的计数器<br>AtomicInteger.incrementAndGet<br>7.synchronized和lock的区别</p><p>8.介绍happen-before<br>9.三个线程保证执行顺序<a href="https://www.cnblogs.com/kaleidoscope/p/9877174.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaleidoscope/p/9877174.html</a></p><h1 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h1><p>1.java 内存模式</p><p>#数据库<br>1.连接池底层说下</p><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><ol><li>解决缓存雪崩和缓存穿透的方案<br><a href="https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TBCEwLVAXdsTszRVpXhVug</a>?</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;p&gt;1.对链表进行归并排序，链表可能有环&lt;br&gt;2.b+树b树的区别，优缺点&lt;/p&gt;
&lt;h1 id=&quot;java基础&quot;&gt;&lt;a href=&quot;#jav
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql读写分离</title>
    <link href="http://shiyangtao.github.io/2019/01/05/mysql-mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://shiyangtao.github.io/2019/01/05/mysql-mysql读写分离/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-01-26T01:14:29.453Z</updated>
    
    <content type="html"><![CDATA[<p>解决问题，读压力，解决不了存储压力<br>读表利用索引提升查询速度，主表可以不建很多索引提升写入速度。</p><h4 id="带来问题"><a href="#带来问题" class="headerlink" title="带来问题"></a>带来问题</h4><ul><li>主从复制延迟<br>例如：注册完账号后，登陆显示无该用户<br>解决方法</li></ul><ol><li>写操作后的读操作指定发给主服务器<br>例如：注册完后，登陆读主库，这种方式和业务强绑定，如果新来的人不知道这样写代码，就会导致一个bug</li><li>读从机失败在去读主机（二次读取）<br>对业务无绑定，只需要对底层数据库访问api进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机读的压力。</li><li>关键业务读写全部指向主机，非关键业务采用读写分离<br>例如：注册登陆业务读写全部访问主机，用户介绍、爱好可以采用读写分离。</li></ol><ul><li>分配机制<br>1.程序代码封装<br>优点实现简单。<br>缺点每个编程语言都要实现一次，如果主从发生切换，则需要所有系统都修改配置并重启<br>目前开源的 淘宝的TDDL<br>2.中间件封装<br>优点支持多种编程语言，主从切换无感知（中间件可探测主从状态，比如发一个写语句，成功的是主）<br>缺点，实现复杂，所有读写请求经过中间件对性能要求高<br>目前开源的 奇虎360 atlas</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;解决问题，读压力，解决不了存储压力&lt;br&gt;读表利用索引提升查询速度，主表可以不建很多索引提升写入速度。&lt;/p&gt;
&lt;h4 id=&quot;带来问题&quot;&gt;&lt;a href=&quot;#带来问题&quot; class=&quot;headerlink&quot; title=&quot;带来问题&quot;&gt;&lt;/a&gt;带来问题&lt;/h4&gt;&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
      <category term="高性能" scheme="http://shiyangtao.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
      <category term="msyql" scheme="http://shiyangtao.github.io/tags/msyql/"/>
    
  </entry>
  
  <entry>
    <title>记一次线上死锁</title>
    <link href="http://shiyangtao.github.io/2018/12/24/mysql-%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%AD%BB%E9%94%81/"/>
    <id>http://shiyangtao.github.io/2018/12/24/mysql-记一次线上死锁/</id>
    <published>2018-12-23T16:00:00.000Z</published>
    <updated>2019-01-26T01:14:39.538Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目做了什么"><a href="#项目做了什么" class="headerlink" title="项目做了什么"></a>项目做了什么</h3><p>这个项目是为了处理一些任务，实现是启动定时任务去处理这些数据，因为项目上线后是集群的，所以为了避免多个节点处理到相同的数据，我们使用select … where  state =0 for update limit 500 来锁住数据，然后update state =2值。这样其他节点就不会重复处理数据了</p><p>同事定时任务的代码大概是这样的，我这里用伪代码表示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transaction</span> <span class="comment">//注意使用for update一定要在事务里边</span></span><br><span class="line">processData()&#123;</span><br><span class="line">bikeIds = findForUpdate();<span class="comment">//select * from test_rawdata where state=0 for update limit 500;</span></span><br><span class="line"><span class="comment">//取出数据，然后先状态改成2</span></span><br><span class="line">updateData(bikeIds);<span class="comment">//update test_rawdata set state = 2 where bikeId in(bikeIds);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了这个地方操作db外，其他地方也有insert delete，所以for update的where条件里必须要有索引，因为如果where 里的字段没有索引的话，for update就不是行锁了，就升级成表锁了。<br>那当处理定时任务时，insert和delete都将会被阻塞，这样并发性太弱了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_rawdata` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;主键ID&apos;,</span><br><span class="line">  `bikeId` varchar(15) NOT NULL COMMENT &apos;车id&apos;,</span><br><span class="line">  `lat` decimal(11,8) NOT NULL DEFAULT &apos;0.00000000&apos; COMMENT &apos;纬度&apos;,</span><br><span class="line">  `lng` decimal(11,8) NOT NULL DEFAULT &apos;0.00000000&apos; COMMENT &apos;经度&apos;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建更新时间，默认当前时间&apos;,</span><br><span class="line">  `state` int(8) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;0表示未处理 1处理中&apos;,</span><br><span class="line">  `accuracy` smallint(6) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;位置精确度&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uniq_bikeid` (`bikeId`),</span><br><span class="line">  KEY `idx_time` (`update_time`) USING BTREE,</span><br><span class="line">  KEY `idx_state` (`state`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=8897633 DEFAULT CHARSET=utf8 COMMENT=&apos;车辆原始位置&apos;;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2455482-a61ae5f452263c18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="db记录"></p><p>trx1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0;</span><br><span class="line">begin;</span><br><span class="line">select * from test_rawdata where state=0 for update;</span><br><span class="line">select sleep(8);</span><br><span class="line">update test_rawdata set state = 2 where bikeId = &quot;7fd9gSBkZ1&quot;;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p><p>trx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set autocommit = 0;</span><br><span class="line">begin;</span><br><span class="line">delete from test_rawdata where bikeId = &apos;7fd9gSBkZ1&apos;; //在trx sleep时间点执行</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></p><p>发生死锁<br>死锁日志<br><img src="https://upload-images.jianshu.io/upload_images/2455482-67be5b7941106602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="https://upload-images.jianshu.io/upload_images/2455482-b4cf0e82040a4632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><img src="https://upload-images.jianshu.io/upload_images/2455482-e874a232cace2f0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>参考链接<br>innodb的锁 <a href="https://zhuanlan.zhihu.com/p/31875702" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31875702</a><br>索引和锁 <a href="https://zhuanlan.zhihu.com/p/40396971" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/40396971</a><br><a href="https://www.jianshu.com/p/1dc4250c6f6f" target="_blank" rel="noopener">https://www.jianshu.com/p/1dc4250c6f6f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;项目做了什么&quot;&gt;&lt;a href=&quot;#项目做了什么&quot; class=&quot;headerlink&quot; title=&quot;项目做了什么&quot;&gt;&lt;/a&gt;项目做了什么&lt;/h3&gt;&lt;p&gt;这个项目是为了处理一些任务，实现是启动定时任务去处理这些数据，因为项目上线后是集群的，所以为了避免多个节点处
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql事务隔离级别</title>
    <link href="http://shiyangtao.github.io/2018/12/08/mysql-mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://shiyangtao.github.io/2018/12/08/mysql-mysql的四种事务隔离级别/</id>
    <published>2018-12-07T16:00:00.000Z</published>
    <updated>2019-01-26T01:14:18.007Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/huanongying/p/7021555.html" target="_blank" rel="noopener">https://www.cnblogs.com/huanongying/p/7021555.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/huanongying/p/7021555.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/huanongying/p/7021555
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql分库分表</title>
    <link href="http://shiyangtao.github.io/2018/12/05/mysql-mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://shiyangtao.github.io/2018/12/05/mysql-mysql分库分表/</id>
    <published>2018-12-04T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:52.824Z</updated>
    
    <content type="html"><![CDATA[<h4 id="业务分库"><a href="#业务分库" class="headerlink" title="业务分库"></a>业务分库</h4><p>按照业务分库，比如用户、商品、订单分库<br>带来的问题</p><ol><li>join 问题<br>不在同一数据库无法join，只能先查一个数据库拿到id列表，在去另外一个库查询</li><li>事务问题<br>原本在同一个数据库的不同表的操作可以在同一个事务里边，分散到不同数据库后无法通过事务统一修改。</li><li>成本问题</li></ol><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><ol><li>垂直分表<br>把不常用且占用了大量空间的列拆分出去。带了的问题是原来只要查询一次就能获取所有所有列，现在需要查询多次</li><li>水平分表</li></ol><ul><li><p>路由</p><ul><li>范围路由<br>按照userId的范围分表，特点可能分配不均（例如按照1000万分表，可能一个表有1000万另一个表只有1000），随着数据的增加平滑的扩充新表，原数据不动</li><li>hash路由<br>按照hash取模分表，特点分配均匀，但是新增表所有数据需要重新分布，但是使用一致性hash算法可以优化</li><li>配置路由<br>增加一个配置表比如 user_router表 包含 user_id,table_id两列,优点灵活，缺点多查询一次表太大了性能也会不好</li></ul></li><li><p>join<br>需要多次join然后合并</p></li><li>count()<br>多个表count()相加，实现简单去诶单性能较低。增加一个记录数表，性能优化了，但是复杂度增加了，必须要同步记录，但是又不能放在同一事务里处理，因为记录表插入失败不应该回滚业务逻辑</li><li>order by<br>数据分散多个字表中，排序无法在数据库中完成，只能由业务或者中间件去分表查询每个子表中的数据然后汇总。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;业务分库&quot;&gt;&lt;a href=&quot;#业务分库&quot; class=&quot;headerlink&quot; title=&quot;业务分库&quot;&gt;&lt;/a&gt;业务分库&lt;/h4&gt;&lt;p&gt;按照业务分库，比如用户、商品、订单分库&lt;br&gt;带来的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;join 问题&lt;br&gt;不在同一数据库无法
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://shiyangtao.github.io/tags/mysql/"/>
    
      <category term="高性能" scheme="http://shiyangtao.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>shell启动socket</title>
    <link href="http://shiyangtao.github.io/2018/12/03/linux%E5%91%BD%E4%BB%A4-shell%E5%90%AF%E5%8A%A8socket/"/>
    <id>http://shiyangtao.github.io/2018/12/03/linux命令-shell启动socket/</id>
    <published>2018-12-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:13:53.324Z</updated>
    
    <content type="html"><![CDATA[<p>nc -l localhost 3000 server<br>nc localhost 3000 client</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nc -l localhost 3000 server&lt;br&gt;nc localhost 3000 client&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="linux" scheme="http://shiyangtao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>grep</title>
    <link href="http://shiyangtao.github.io/2018/11/03/linux%E5%91%BD%E4%BB%A4-grep/"/>
    <id>http://shiyangtao.github.io/2018/11/03/linux命令-grep/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:13:46.080Z</updated>
    
    <content type="html"><![CDATA[<p>grep 后面带上-A -B -C 参数可以多显示几行内容</p><p>grep -A 5 可以显示匹配内容以及后面的5行内容<br>grep -B 5 可以显示匹配内容以及前面的5行内容<br>grep -C 5 可以显示匹配内容以及前后面的5行内容</p><p>grep “” logfile|wc -l 显示匹配的行数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;grep 后面带上-A -B -C 参数可以多显示几行内容&lt;/p&gt;
&lt;p&gt;grep -A 5 可以显示匹配内容以及后面的5行内容&lt;br&gt;grep -B 5 可以显示匹配内容以及前面的5行内容&lt;br&gt;grep -C 5 可以显示匹配内容以及前后面的5行内容&lt;/p&gt;
&lt;p&gt;gr
      
    
    </summary>
    
    
      <category term="linux" scheme="http://shiyangtao.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>线程池构造方法</title>
    <link href="http://shiyangtao.github.io/2018/10/03/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://shiyangtao.github.io/2018/10/03/java并发编程-java线程池/</id>
    <published>2018-10-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:11:45.863Z</updated>
    
    <content type="html"><![CDATA[<p>Java中的ThreadPoolExecutor类<br>提供了四个构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;</span><br><span class="line">    .....</span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue);</span><br><span class="line"> </span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);</span><br><span class="line"> </span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);</span><br><span class="line"> </span><br><span class="line">    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="参数解读"><a href="#参数解读" class="headerlink" title="参数解读"></a>参数解读</h5><ul><li>corePoolSize: 核心线程大小 </li><li>maximumPoolSize: 最大线程数</li><li>workQueue: 一个阻塞队列，用来存储等待执行的任务，由如下选择ArrayBlockingQueue 有界队列;<br>LinkedBlockingQueue 无界队列;<br>SynchronousQueue同步移交，不是一个真正的队列，而是一种在线程中移交的机制。将一个元素放入到队列中必须有一个线程等待接受这个任务，如果没有线程正在等待，且线程池当前大小小于最大值，那么创建一个新的线程去执行，否则根据饱和机制这个任务将被拒绝</li><li>keepAliveTime: 表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li><li>threadFactory：线程工厂，主要用来创建线程；可以自己写个线程工厂来个性化自己的线程比如名字，或者计数</li><li>rejectedExecutionHandler:<br>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务<h5 id="线程创建逻辑ThreadPoolExecutor里execute方法"><a href="#线程创建逻辑ThreadPoolExecutor里execute方法" class="headerlink" title="线程创建逻辑ThreadPoolExecutor里execute方法"></a>线程创建逻辑ThreadPoolExecutor里execute方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    //  “线程数” 的整数</span><br><span class="line">    int c = ctl.get();</span><br><span class="line"></span><br><span class="line">    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        // 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        // 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span><br><span class="line"></span><br><span class="line">    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        /* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         */</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        // 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    // 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>1.如果当前线程数少于 corePoolSize，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；<br>2.如果当前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中，等待线程池中的线程去队列中取任务；<br>3.如果队列已满，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略</p><p>Executors里的三个静态方法</p><ul><li>生成固定大小线程池<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p><p>过程分析：刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads。</p><ul><li><p>生成只有一个线程的固定线程池，这个更简单，和上面的一样，只要设置线程数为 1 就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。<br>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p><p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line">// corePoolSize 为 0，所以不会进到这个 if 分支</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    if (addWorker(command, true))</span><br><span class="line">        return;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br><span class="line">// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 false</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    int recheck = ctl.get();</span><br><span class="line">    if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    else if (workerCountOf(recheck) == 0)</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://javadoop.com/post/java-thread-pool#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">https://javadoop.com/post/java-thread-pool#%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java中的ThreadPoolExecutor类&lt;br&gt;提供了四个构造方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
    
      <category term="java并发编程" scheme="http://shiyangtao.github.io/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>分布式技术栈</title>
    <link href="http://shiyangtao.github.io/2018/09/21/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    <id>http://shiyangtao.github.io/2018/09/21/分布式-分布式技术栈/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2019-01-25T13:48:14.440Z</updated>
    
    <content type="html"><![CDATA[<p>构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。</p><ul><li>大流量处理。通过集群技术把大规模并发请求的负载分散到不同的机器上。</li><li>关键业务保护。提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）。如果流量过大，需要对业务降级，以保护关键业务流转。</li></ul><p>说白了就是干两件事。一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。</p><p>##提高架构的性能<br>咱们先来看看，提高系统性能的常用技术。<img src="https://upload-images.jianshu.io/upload_images/2455482-b2a5188453c5a060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>缓存系统。加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。</p></li><li><p>负载均衡系统，是做水平扩展的关键技术。其可以用多台机器来共同分担一部分流量请求。</p></li><li><p>异步调用。异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。</p></li><li><p>数据分区和数据镜像。数据分区是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而数据镜像是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。</p></li></ul><p>对于一般公司来说，在初期，会使用读写分离的数据镜像方式，而后期会采用分库分表的方式。</p><p>#提高架构的稳定性<br>接下来，咱们来看看提高系统系统稳定性的一些常用技术。<img src="https://upload-images.jianshu.io/upload_images/2455482-b3c90af63f328b5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>服务拆分，主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。</p></li><li><p>服务冗余，是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。</p></li><li><p>限流降级。当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。</p></li><li><p>高可用架构，通常来说是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。</p></li><li><p>高可用运维，指的是 DevOps 中的 CI（持续集成）/CD（持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。</p></li></ul><p>上述这些技术非常有技术含量，而且需要投入大量的时间和精力。</p><p>##分布式系统的关键技术<br>而通过上面的分析，我们可以看到，引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决。</p><ul><li><p>服务治理。服务拆分、服务调用、服务发现，服务依赖，服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。</p></li><li><p>架构软件管理。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。</p></li><li><p>DevOps。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。</p></li><li><p>自动化运维。有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。</p></li><li><p>资源调度管理。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。</p></li><li><p>整体架构监控。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。</p></li><li><p>流量控制。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。</p></li></ul><p>此时，你会发现，要做好这么多的技术，或是要具备这么多的能力，简直就是一个门槛，是一个成本巨高无比的技术栈，看着就都头晕。要实现出来得投入多少人力、物力和时间啊。是的，这就是分布式系统中最大的坑。</p><p>不过，我们应该庆幸自己生活在了一个非常不错的年代。今天有一个技术叫——Docker，通过 Docker 以及其衍生出来的 Kubernetes 之类的软件或解决方案，大大地降低了做上面很多事情的门槛。Docker 把软件和其运行的环境打成一个包，然后比较轻量级地启动和运行。在运行过程中，因为软件变成了服务可能会改变现有的环境。但是没关系，当你重新启动一个 Docker 的时候，环境又会变成初始化状态。</p><p>这样一来，我们就可以利用 Docker 的这个特性来把软件在不同的机器上进行部署、调度和管理。如果没有 Docker 或是 Kubernetes，那么你可以认为我们还活在“原始时代”。现在你知道为什么 Docker 这样的容器化虚拟化技术是未来了吧。因为分布式系统已经是完全不可逆转的技术趋势了。</p><p>但是，上面还有很多的技术是 Docker 及其周边技术没有解决的，所以，依然还有很多事情要做。那么，如果是一个一个地去做这些技术的话，就像是我们在撑开一张网里面一个一个的网眼，本质上这是使蛮力的做法。我们希望可以找到系统的“纲”，一把就能张开整张网。那么，这个纲在哪里呢？</p><p>##分布式系统的“纲”<br>总结一下上面讲述的内容，你不难发现，分布式系统有五个关键技术，它们是：</p><ul><li>全栈系统监控；</li><li>服务 / 资源调度；</li><li>流量调度；</li><li>状态 / 数据调度；</li><li>开发和运维的自动化。</li></ul><p>而最后一项——开发和运维的自动化，是需要把前四项都做到了，才有可能实现的。所以，最为关键是下面这四项技术，即应用整体监控、资源和服务调度、状态和数据调度及流量调度，它们是构建分布式系统最最核心的东西。<br><img src="https://upload-images.jianshu.io/upload_images/2455482-2a79e0a16d269d47.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>后面的文章中，我会一项一项地解析这些关键技术。</p><p>小结<br>回顾一下今天的要点内容。首先，我总结了分布式系统需要干的两件事：一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。然后分别从这两个方面阐释，需要通过哪些技术来实现，并梳理出其中的技术难点及可能会带来的问题。最后，欢迎你分享一下你在解决系统的性能和可用性方面使用到的方法和技巧。</p><p>虽然 Docker 及其衍生出来的 Kubernetes 等软件或解决方案，能极大地降低很多事儿的门槛。但它们没有解决的问题还有很多，需要掌握分布式系统的五大关键技术，从根本上解决问题。后面我将陆续撰写几篇文章一一阐述这几大关键技术，详见文末给出的《分布式系统架构的本质》系列文章的目录。</p><ul><li><a href="https://time.geekbang.org/column/article/1411?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统架构的冰与火</a></li><li><a href="https://time.geekbang.org/column/article/1505?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">从亚马逊的实践，谈分布式系统的难点</a></li><li><a href="https://time.geekbang.org/column/article/1512?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统的技术栈</a></li><li><a href="https://time.geekbang.org/column/article/1513?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统关键技术：全栈监控</a></li><li><a href="https://time.geekbang.org/column/article/1604?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统关键技术：服务调度</a></li><li><a href="https://time.geekbang.org/column/article/1609?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">分布式系统关键技术：流量与数据调度</a></li><li><a href="https://time.geekbang.org/column/article/1610?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">洞悉 PaaS 平台的本质</a></li><li><a href="https://time.geekbang.org/column/article/2080?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">推荐阅读：分布式系统架构经典资料</a></li><li><a href="https://time.geekbang.org/column/article/2421?code=6yt0w1pFUwTy3XPtebdloqHiFGfY2aAglc6FhjOvMK8%3D" target="_blank" rel="noopener">推荐阅读：分布式数据调度相关论文</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2455482-88afd0b9e2f35b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大流量处理。通过集群技术把大规模并发请求的负载分散到不同的机器上。&lt;/li&gt;
&lt;li&gt;关键业务保护。提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应
      
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="分布式" scheme="http://shiyangtao.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="http://shiyangtao.github.io/2018/09/21/%E9%9D%A2%E8%AF%95-jianli/"/>
    <id>http://shiyangtao.github.io/2018/09/21/面试-jianli/</id>
    <published>2018-09-20T16:00:00.000Z</published>
    <updated>2019-01-26T10:51:12.372Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><ul><li>史洋涛/男/1990 </li><li>工作年限：4年</li><li>手机（微信）：13621204061</li><li>邮箱：<a href="mailto:yangtao.shi@gmail.com" target="_blank" rel="noopener">yangtao.shi@gmail.com</a></li><li>博客：<a href="http://shiyangtao.github.io">http://shiyangtao.github.io</a></li></ul><hr><h2 id="自我描述"><a href="#自我描述" class="headerlink" title="自我描述"></a>自我描述</h2><ul><li>4年＋java开发经验</li><li>极客，热爱编程，喜欢专研</li><li>渴求自我提升、实现价值</li><li>工作认真，积极性高，思路清晰，善于思考，能独立分析和解决问题</li><li>责任心强，具有较强的沟通能力及团队合作精神和承受压力能力。</li></ul><hr><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p> 2010.9-2014.7   石家庄学院             软件工程           本科（统招）   </p><hr><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><h3 id="北京安信创富科技有限公司-（-2015-09-至今-）-后端团队leader"><a href="#北京安信创富科技有限公司-（-2015-09-至今-）-后端团队leader" class="headerlink" title="北京安信创富科技有限公司             （ 2015.09 - 至今 ）                              后端团队leader"></a>北京安信创富科技有限公司             （ 2015.09 - 至今 ）                              后端团队leader</h3><p>负责把产品的需求转化为规范的开发计划，并对产品需求进行合理化建议，按计划确保开发工作顺利进行。带三至四人后端团队开发、任务分配，并且主导系统全局分析设计和实施，包括接口的设计，数据库设计，第三方服务接入，根据业务来选择实施落地的技术，最后按质按量的完成项目需求。后期根据业务增长针对性的做优化，比如缓存系统，负载均衡，服务拆分，异步调用削峰，数据分区等，来提高架构的性能和稳定性</p><h4 id="客慧来-收银系统（2016-05-至今）"><a href="#客慧来-收银系统（2016-05-至今）" class="headerlink" title="客慧来-收银系统（2016.05-至今）"></a>客慧来-收银系统（2016.05-至今）</h4><p>基于python-libcef开发的windows桌面收银和云端java结合的智能收银系统, 主要为商家提供除基础收银功能外的智能买单，灵活的营销体系、强大的会员系统、营业手机监控等功能，截止目前有1000+商家把传统收银软件替换成我们的收银系统，更加智能和易用</p><ul><li>负责：<br>收银本地和云端产品的接口和数据库的设计，主要模块支付体系、会员体系、营销体系、第三方对接等的开发和功能点的任务分配，根据后期数据增长，需求变化对系统实现功能扩展，服务拆分、性能优化、日志监控、安全性升级等，使系统高性能、高稳定性、安全性。  </li><li><p>解决的问题：</p><ul><li>客户端数据库：选用sqlite数据库，并使用sqlcipher加密，使用SQLAlchemy作为orm框架来提高开发速度，实现数据库版本控制，数据备份</li><li>支付系统：微信支付／支付宝支付／第三方支付（beecloud）的对接，支持多种支付场景（刷卡，扫码，混合），根据商户的各种情况一键切换</li><li>小程序工具开发：小程序和公众号用户关联，合并用户，历史数据刷新</li><li>会员系统优化：按业务拆分数据库，消息队列(SQS)削峰提高性能，实现用户行为收集高并发</li><li>爬取第三方数据：随着对接商家的增多，有会员迁移的需求，有些商家之前使用的平台不支持导出数据，Python Scrapy爬取会员数据</li><li>集群化：服务拆分、RPC调用、容器化（Docker Swarm）、日志收集与监控(Amazon CloudWatch)<h4 id="口碑isv（2017-02-至今）"><a href="#口碑isv（2017-02-至今）" class="headerlink" title="口碑isv（2017.02-至今）"></a>口碑isv（2017.02-至今）</h4>该项目是一个基于支付宝平台，为商家提供便捷支付和营销功能，打通商家收银系统，提供更加支付体验，相比口碑同期ISV，我们终端设备插件可实时配置与打通，并且打通速度快，支持设备广，目前仍有2000+家在使用，曾被口碑平台推荐</li></ul></li><li><p>负责模块：<br>对接口碑功能、商户收银的打通、后期业务增长系统优化、服务拆分、服务冗余</p></li><li>解决的问题：<ul><li>口碑券状态不同步的问题：采取定时通过口碑提供的接口去同步状态，还有给用户发券失败的错误信息异步分析，如果是因为发送已下架的券，就会主动去把状态修改掉</li><li>并发发券提升用户体验：启用多线程去发券，前后端协调一起优化用户体验</li><li>结账前优惠计算问题：团队通过多种测试用例来推算口碑券核销的优先级互斥性，并且记录着给用户发放的券，来实现这个需求。虽然这种方式是有误差的，但是灰度上线经运行一段时间后根据log分析准确率很高，用户体验得到了提升，得到了商户的认可</li><li>收银软件打通：采用数据库打通机制解决，破解商户收银的数据库，云端和本地client通过websocket通信，本地插件把云端指令集翻译成sql语句通过odbc 去查询商家收银数据库，来获得菜品／桌台／订单数据，保证稳定性和准确性</li><li>秒付性能问题：根据后期业务增长，和口碑对isv的高性能和稳定性要求，都使用redis缓存起来常用的查询数据，并且实现服务拆分（重用服务模块），服务冗余（避免单点故障），消息队列削峰（SQS）使用docker 技术实现服务的弹性伸缩，最后通过口碑压测，峰值能达到1000+qps<br>###准成品电商平台  （2015.09-2016.08 ）<br>该项目是一个基于微信平台的一个电商项目，主要向用户出售半成品，项目主要包括：用户登录、用户储值、下单、客服系统、订单消息系统(对商家、对用户)、快递配送系统、后台库存系统、邮件系统，项目截止前，北京有数家半成品供应商，个人消费者10000+，合作小商户等多达1000+，配送基本覆盖了北京全范围</li></ul></li><li>负责模块：<br>用户登陆，微信授权、下单、订单超时、订单配送、拆单、跳单逻辑、库存管理、报表数据等主要模块</li><li>遇到的问题：<ul><li>库存管理：供应商有后台来编辑某个菜品的库存量，库存不足时菜品不能下单，为了避免多人同时下单操作单个菜品的时，引起的并发问题，采用redis的transaction机制，避免高并发引起的库存数量错误问题</li><li>订单数量多后数据库压力：分库分表（Sharding-JDBC）</li></ul></li></ul><h3 id="北京源讯信息技术中国有限公司（2014-10-2015-09-）-java开发工程师"><a href="#北京源讯信息技术中国有限公司（2014-10-2015-09-）-java开发工程师" class="headerlink" title="北京源讯信息技术中国有限公司（2014.10 - 2015.09 ）                 java开发工程师"></a>北京源讯信息技术中国有限公司（2014.10 - 2015.09 ）                 java开发工程师</h3><p>负责公司主要项目维护和个性化开发，性能优化，针对客户反馈出来的问题进行有效的沟通，并解决问题</p><h3 id="北京东方飞扬科技有限公司（2013-12-2014-09-）-java开发工程师"><a href="#北京东方飞扬科技有限公司（2013-12-2014-09-）-java开发工程师" class="headerlink" title="北京东方飞扬科技有限公司（2013.12 - 2014.09 ）                java开发工程师"></a>北京东方飞扬科技有限公司（2013.12 - 2014.09 ）                java开发工程师</h3><p>负责公司定制化项目的敏捷开发，参与总体需求分析与架构设计、领域模型设计、数据库设计、SSH架构搭建及JBPM</p><h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><ul><li>java基础扎实，熟悉Jvm，有jvm调优经验</li><li>能够熟练的应用各种框架spring struts hibernate spring Ibatis jpa</li><li>熟悉mysql等关系型数据库，以及数据库调优、sql优化，熟练掌握sql语言</li><li>熟悉redis，mogodb，dynamodb等非关系型数据库</li><li>熟悉Linux操作系统，会使用常用的linux命令，有linux服务器的部署经验</li><li>熟悉docker容器技术，docker编排工具</li><li>熟悉python语言，用于日常脚本和爬虫</li><li>熟悉消息队列 掌握rabbitmq、sqs等消息队列</li><li>熟悉分布式、缓存、消息、异步等机制</li><li>熟悉aws云平台，dynamodb，s3，sqs模块发</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;个人简介&quot;&gt;&lt;a href=&quot;#个人简介&quot; class=&quot;headerlink&quot; title=&quot;个人简介&quot;&gt;&lt;/a&gt;个人简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;史洋涛/男/1990 &lt;/li&gt;
&lt;li&gt;工作年限：4年&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>面试计数器相关</title>
    <link href="http://shiyangtao.github.io/2018/05/20/%E9%9D%A2%E8%AF%95-%E9%9D%A2%E8%AF%95-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://shiyangtao.github.io/2018/05/20/面试-面试-计数器相关/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:41.329Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面试官问："><a href="#面试官问：" class="headerlink" title="面试官问："></a>面试官问：</h4><p>文件里有m个身份证号，统计每个身份证号出现的次数</p><h4 id="回答："><a href="#回答：" class="headerlink" title="回答："></a>回答：</h4><p>使用hashMap实现，key作为身份证号<br><em>ContainsKey</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; freq = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">    int count = freq.containsKey(word) ? freq.get(word) : 0;</span><br><span class="line">    freq.put(word, count + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="面试官问：-1"><a href="#面试官问：-1" class="headerlink" title="面试官问："></a>面试官问：</h4><p>还能优化吗</p><h4 id="回答：-1"><a href="#回答：-1" class="headerlink" title="回答："></a>回答：</h4><p><em>TestForNull</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; freq = new HashMap&lt;String, Integer&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">  Integer count = freq.get(word);</span><br><span class="line">  if (count == null) &#123;</span><br><span class="line">      freq.put(word, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    freq.put(word, count + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>减少调用containsKey方法的开销</p><h4 id="面试官问：-2"><a href="#面试官问：-2" class="headerlink" title="面试官问："></a>面试官问：</h4><p>如果是高并发情况呢</p><h4 id="回答：-2"><a href="#回答：-2" class="headerlink" title="回答："></a>回答：</h4><p>采用ConcurrentHashMap去做，线程安全的</p><h4 id="面试官问：-3"><a href="#面试官问：-3" class="headerlink" title="面试官问："></a>面试官问：</h4><p>高并发下HashMap有什么问题吗</p><h4 id="回答：-3"><a href="#回答：-3" class="headerlink" title="回答："></a>回答：</h4><p>并发情况下使用HashMap造成Race Condition，从而导致死循环，CPU占用率会达到100%<br><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">博文链接hashMap死循环</a></p><h4 id="面试官问：-4"><a href="#面试官问：-4" class="headerlink" title="面试官问："></a>面试官问：</h4><p>ok 用ConcurrentHashMap 实现下</p><h4 id="回答：-4"><a href="#回答：-4" class="headerlink" title="回答："></a>回答：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap &lt;String, Integer&gt; freq = new ConcurrentHashMap &lt;String, Integer&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">  Integer count = freq.get(word);</span><br><span class="line">  if (count == null) &#123;</span><br><span class="line">      freq.put(word, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      freq.put(word, count + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试官问：-5"><a href="#面试官问：-5" class="headerlink" title="面试官问："></a>面试官问：</h4><p>确定能实现？</p><h4 id="回答：-5"><a href="#回答：-5" class="headerlink" title="回答："></a>回答：</h4><p>实现不了 put操作会覆盖，比如两个线程同时进来读到了都是4，那么都会put 5进去，<br>可以给方法加上synchronized锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap &lt;String, Integer&gt; freq = new ConcurrentHashMap &lt;String, Integer&gt;();</span><br><span class="line">public synchronized void incr (String word)&#123;</span><br><span class="line">  Integer count = freq.get(word);</span><br><span class="line">  if (count == null) &#123;</span><br><span class="line">      freq.put(word, 1);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      freq.put(word, count + 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="面试官问：-6"><a href="#面试官问：-6" class="headerlink" title="面试官问："></a>面试官问：</h4><p>嗯嗯 加锁确实能实现，但是性能差点，能优化下吗</p><h4 id="回答-当时回答的不好-："><a href="#回答-当时回答的不好-：" class="headerlink" title="回答(当时回答的不好)："></a>回答(当时回答的不好)：</h4><p>能,采用cas方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;String, AtomicLong&gt; map = new ConcurrentHashMap&lt;String, AtomicLong&gt;();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">  map.putIfAbsent(word, new AtomicLong(0));</span><br><span class="line">  map.get(word).incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以采用  AtomicLongMap，AtomicLongMap是Google Guava项目的一个类，它是线程安全、支持并发访问的，通过CAS方式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AtomicLongMap&lt;String&gt; map = AtomicLongMap.create();</span><br><span class="line">public void incr (String word)&#123;</span><br><span class="line">   map.getAndIncrement(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="延伸："><a href="#延伸：" class="headerlink" title="延伸："></a>延伸：</h4><p>AtomicLong – 这组类使用CAS（比较并交换）处理器指令来更新计数器的值。听起来不错，真的是这样吗？是也不是。好的一面是它通过一个直接机器码指令设置值时，能够最小程度地影响其他线程的执行。坏的一面是如果它在与其他线程竞争设置值时失败了，它不得不再次尝试。在高竞争下，这将转化为一个自旋锁，线程不得不持续尝试设置值，无限循环直到成功。这可不是我们想要的方法。<a href="http://www.importnew.com/11345.html" target="_blank" rel="noopener">让我们进入Java 8的LongAdders</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面试官问：&quot;&gt;&lt;a href=&quot;#面试官问：&quot; class=&quot;headerlink&quot; title=&quot;面试官问：&quot;&gt;&lt;/a&gt;面试官问：&lt;/h4&gt;&lt;p&gt;文件里有m个身份证号，统计每个身份证号出现的次数&lt;/p&gt;
&lt;h4 id=&quot;回答：&quot;&gt;&lt;a href=&quot;#回答：&quot; c
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>必要商城面试</title>
    <link href="http://shiyangtao.github.io/2018/05/13/%E9%9D%A2%E8%AF%95-%E5%BF%85%E8%A6%81%E5%95%86%E5%9F%8E%E9%9D%A2%E8%AF%95/"/>
    <id>http://shiyangtao.github.io/2018/05/13/面试-必要商城面试/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:30.362Z</updated>
    
    <content type="html"><![CDATA[<p>无笔试<br>第一轮</p><ul><li>你看过哪些java源码 或者框架的源码</li><li>项目里用了多线程的地方 线程池相关</li><li>数据库隔离</li><li>spring 原理 ioc aop</li><li>自己设计一个券系统，并画出er图</li><li>根据用户的优惠券，快速算出最佳优惠的策略</li></ul><p>第二轮</p><ul><li>业务数据量大，如何优化</li><li>订单超时过期实现（回答延迟mq、redis过期key订阅、Linux定时任务，面试官感觉mq会出现死信，redis或linux会down 有没有更好的方案，没有get到他想考察的点</li></ul><p>第三轮</p><ul><li>依赖第三方服务，比如支付结果的轮询，如果第三方down掉，支付服务会down或者重启后又down是什么原因（考察http 链接的开销，设置过期时间）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无笔试&lt;br&gt;第一轮&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你看过哪些java源码 或者框架的源码&lt;/li&gt;
&lt;li&gt;项目里用了多线程的地方 线程池相关&lt;/li&gt;
&lt;li&gt;数据库隔离&lt;/li&gt;
&lt;li&gt;spring 原理 ioc aop&lt;/li&gt;
&lt;li&gt;自己设计一个券系统，并画出er
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>boss直聘面试15分钟gg</title>
    <link href="http://shiyangtao.github.io/2018/05/03/%E9%9D%A2%E8%AF%95-boss%E7%9B%B4%E8%81%98%E9%9D%A2%E8%AF%9515%E5%88%86gg/"/>
    <id>http://shiyangtao.github.io/2018/05/03/面试-boss直聘面试15分gg/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2019-01-26T01:16:01.320Z</updated>
    
    <content type="html"><![CDATA[<p>#笔试题</p><ul><li>hashmap遍历</li><li>linux log 查处访问前十的IP地址</li><li>三个远程方法a b c 返回类型一样 有一个方法执行完就返回<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1>讲讲hashmap hashmap的几种构造方法<br>讲讲一致性hash算法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#笔试题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hashmap遍历&lt;/li&gt;
&lt;li&gt;linux log 查处访问前十的IP地址&lt;/li&gt;
&lt;li&gt;三个远程方法a b c 返回类型一样 有一个方法执行完就返回&lt;h1 id=&quot;面试&quot;&gt;&lt;a href=&quot;#面试&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="面试" scheme="http://shiyangtao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>运行时栈帧结构</title>
    <link href="http://shiyangtao.github.io/2018/03/24/jvm-2018-03-24-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/"/>
    <id>http://shiyangtao.github.io/2018/03/24/jvm-2018-03-24-运行时栈帧结构/</id>
    <published>2018-03-23T16:00:00.000Z</published>
    <updated>2019-01-25T13:32:42.009Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2455482-1d40e2c7f2f7dc6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="栈帧概念结构"><br><a id="more"></a><br>每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（CurrentStackFrame），与这个栈帧相关联的方法称为当前方法（CurrentMethod）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如上图所示。</p><ul><li><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2>局部变量表用于存放方法参数和方法内定义的局部变量，在java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中明确了该方法所需要分配的局部变量表的最大容量。</li></ul><p>局部变量表的容量以变量槽（VariableSlot，下称Slot）为最小单位，一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有boolean、byte、char、short、int、float、reference和returnAddress8种类型。前面6种不需要多加解释，读者可以按照Java语言中对应数据类型的概念去理解它们，而第7种reference类型表示对一个对象实例的引用，虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但一般来说，虚拟机实现至少都应当能通过这个引用做到两点，一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束。</p><p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字”this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p><p>为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接影响到系统的垃圾收集行为，请看代码演示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">  System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行java -verbose:gc SlotTest</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">[GC (System.gc())  <span class="number">66867</span>K-&gt;<span class="number">66040</span>K(<span class="number">125952</span>K), <span class="number">0.0164932</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  66040K-&gt;65813<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, 0.0103833 secs]</span></span><br></pre></td></tr></table></figure></p><p>代码很简单，即向内存填充了64MB的数据，然后通知虚拟机进行垃圾收集。我们在虚拟机运行参数中加上”-verbose:gc”来看看垃圾收集的过程，发现在System.gc()运行后并没有回收这64MB的内存，没有回收placeholder所占的内存能说得过去，因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自然不敢回收placeholder的内存。那我们把代码修改一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">   System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[GC (System.gc())  <span class="number">66867</span>K-&gt;<span class="number">65992</span>K(<span class="number">125952</span>K), <span class="number">0.0054315</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  65992K-&gt;65813<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, 0.0111123 secs]</span></span><br></pre></td></tr></table></figure></p><p>加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了，但执行一下这段程序，会发现运行结果如下，还是有64MB的内存没有被回收，这又是为什么呢？在解释为什么之前，我们先对这段代码进行第二次修改，在调用System.gc()之前加入一行”int a=0；”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[GC (System.gc())  <span class="number">66867</span>K-&gt;<span class="number">66008</span>K(<span class="number">125952</span>K), <span class="number">0.0024539</span> secs]</span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(System.gc()</span>)  66008K-&gt;277<span class="title">K</span><span class="params">(<span class="number">125952</span>K)</span>, 0.0105643 secs]</span></span><br></pre></td></tr></table></figure></p><p>这个修改看起来很莫名其妙，但运行一下程序，却发现这次内存真的被正确回收了。<br>placeholder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。第一次修改中，代码虽然已经离开了placeholder的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder原本所占用的Slot还没有被其他变量所复用，所以作为GCRoots一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p><p>代码示例说明了赋null值的操作在某些情况下确实是有用的，但笔者的观点是不应当对赋null值的操作有过多的依赖，更没有必要把它当做一个普遍的编码规则来推广。原因有两点，从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法，更关键的是，从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行概念模型的理解之上的。在虚拟机使用解释器执行时，通常与概念模型还比较接近，但经过JIT编译器后，才是虚拟机执行代码的主要方式，赋null值的操作在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。字节码被编译为本地代码后，对GCRoots的枚举也与解释执行时期有巨大差别，以前面例子来看，第二个块代码清单在经过JIT编译后，System.gc()执行时就可以正确地回收掉内存，无须加一句”int a = 0;”</p><p>关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量（static修饰）那样存在“准备阶段”。通过前面类加载的讲解，我们已经知道类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但没有赋初始值是不能使用的，不要认为Java中任何情况下都存在诸如整型变量默认为0，布尔型变量默认为false等这样的默认值。如下面代码所示，这段代码其实并不能运行，还好编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。<br><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/2455482-c5e6450e37f66dff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2>操作数栈（OperandStack）也常称为操作栈，它是一个后入先出（LastInFirstOut,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</li></ul><p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。</p><p>举个例子，整数加法的字节码指令iadd<a href="将栈顶两int型数值相加并将结果压入栈顶">^1</a>在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。</p><p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但在大多虚拟机的实现里都会做一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无须进行额外的参数复制传递，重叠的过程如图所示。<br><img src="https://images.weserv.nl/?url=https://upload-images.jianshu.io/upload_images/2455482-50160ad6889113c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个栈帧之间的数据共享"></p><ul><li><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</li><li><h2 id="方法返回值"><a href="#方法返回值" class="headerlink" title="方法返回值"></a>方法返回值</h2>当一个方法开始执行后，只有两种方式可以退出这个方法。</li></ul><p>第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。</p><p>另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p><p>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2455482-1d40e2c7f2f7dc6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;栈帧概念结构&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载器</title>
    <link href="http://shiyangtao.github.io/2017/09/21/jvm-2017-09-21-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://shiyangtao.github.io/2017/09/21/jvm-2017-09-21-类加载器/</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2019-01-25T11:54:57.359Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。<br><a id="more"></a><br>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<br>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：</p><ul><li>启动类加载器（BootstrapClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；</li><li>其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</li></ul><p>从Java开发人员的角度来看，类加载器还可以划分得更细致一些，绝大部分Java程序都会使用到以下3种系统提供的类加载器：</p><ul><li><p>启动类加载器（BootstrapClassLoader）：前面已经介绍过，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用null代替即可，如代码清单7-9所示为java.lang.ClassLoader.getClassLoader()方法的代码片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class loader for the class.  Some implementations may use</span></span><br><span class="line"><span class="comment"> * null to represent the bootstrap class loader. This method will return</span></span><br><span class="line"><span class="comment"> * null in such implementations if this class was loaded by the bootstrap</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = getClassLoader0();</span><br><span class="line">    <span class="keyword">if</span> (cl == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展类加载器（ExtensionClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p></li><li>应用程序类加载器（ApplicationClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如图所示。<br><img src="https://upload-images.jianshu.io/upload_images/2455482-4eeccdffc73cfc8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类加载器双亲委派模型（ParentsDelegationModel）"><br>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p><h4 id="工作过程："><a href="#工作过程：" class="headerlink" title="工作过程："></a>工作过程：</h4><p>如果一个类加载器收到一个类加载的请求，它首先不会自己去尝试加载这个类，而是先委派给它的父类加载器去加载，每一个层次的加载器都是如此。因此所有的类加载请求都会传到启动类加载器，只有当父类加载器反馈自己无法完成（它的搜索范围没有找到所需的类）时，子加载器才会自己去加载。</p><h4 id="好处："><a href="#好处：" class="headerlink" title="好处："></a>好处：</h4><p>有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。如果读者有兴趣的话，可以尝试去编写一个与rt.jar类库中已有类重名的Java类，将会发现可以正常编译，但永远无法被加载运行。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h4><p>双亲委派模型对于保证Java程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在java.lang.ClassLoader的loadClass()方法之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // First, check if the class has already been loaded</span><br><span class="line">        // 检查类是否已经被加载过了</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">                // 如果父类抛出ClassNotFoundException</span><br><span class="line">                //说明父类无法完成加载请求</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                // 在父类无法加载的时候调用自身的findClass进行加载</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br></pre></td></tr></table></figure></p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>上文提到过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。在Java的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过3较大规模的“被破坏”情况。</p><ol><li>第一次破坏<br>&emsp;&emsp;由于双亲委派模型在JDK1.2之后才被引入，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass()，在JDK1.2之前，用户去继承java.lang.ClassLoader的唯一目的就是为了重写loadClass()方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的loadClass()。JDK1.2之后已不提倡用户再去覆盖loadClass()方法，而应当把自己的类加载逻辑写到findClass()方法中，在loadClass()方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</li><li>第二次破坏<br>&emsp;&emsp;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？这并非是不可能的事情，一个典型的例子便是<a href="https://www.ibm.com/developerworks/cn/java/j-jndi/index.html" target="_blank" rel="noopener">JNDI服务</a>，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时放进去的rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI,ServiceProviderInterface）的代码，但启动类加载器不可能“认识”这些代码啊!那该怎么办？<br>&emsp;&emsp;为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（ThreadContextClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>&emsp;&emsp;有了线程上下文类加载器，就可以做一些“舞弊”的事情了，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</li><li>第三次破坏<br>&emsp;&emsp;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（HotDeployment）等，说白了就是希望应用程序能像我们的计算机外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用停机也不用重启。对于个人计算机来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是企业级软件开发者具有很大的吸引力。<br>&emsp;&emsp;Sun公司所提出的JSR-294[1]、JSR-277[2]规范在与JCP组织的模块化规范之争中落败给JSR-291（即OSGiR4.2），虽然Sun不甘失去Java模块化的主导权，独立在发展Jigsaw项目，但目前OSGi已经成为了业界“事实上”的Java模块化标准，而OSGi实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<br>&emsp;&emsp;这里“被破坏”并不带有贬义的感情色彩。只要有足够意义和理由，突破已有的原则就可认为是一种创新。正如OSGi中的类加载器并不符合传统的双亲委派的类加载器，并且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但在Java程序员中基本有一个共识：<strong>OSGi中对类加载器的使用是很值得学习的，弄懂了OSGi的实现，就可以算是掌握了类加载器的精髓。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>强-软-弱-虚引用</title>
    <link href="http://shiyangtao.github.io/2017/09/21/jvm-%E5%BC%BA-%E8%BD%AF-%E5%BC%B1-%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    <id>http://shiyangtao.github.io/2017/09/21/jvm-强-软-弱-虚引用/</id>
    <published>2017-09-20T16:00:00.000Z</published>
    <updated>2019-01-25T13:44:42.008Z</updated>
    
    <content type="html"><![CDATA[<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p><p>1 强引用</p><p>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p><p>2 软引用</p><p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p><p>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>3 弱引用</p><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p>应用场景：弱应用同样可用于内存敏感的缓存。</p><p>4 虚引用</p><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue);<br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p><p>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。<br>看下边两个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.*;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;VeryBig&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;VeryBig&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Reference&lt;? extends VeryBig&gt; ref = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((ref = rq.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"In queue: "</span>+ ((VeryBigWeakReference) (ref)).id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">changeWeakToStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">Object o = <span class="keyword">null</span>;</span><br><span class="line">LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = <span class="keyword">new</span> LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">VeryBigWeakReference veryBigWeakReference = <span class="keyword">new</span> VeryBigWeakReference(<span class="keyword">new</span> VeryBig(<span class="string">"Weak "</span> + i), rq);</span><br><span class="line">weakList.add(veryBigWeakReference);</span><br><span class="line">System.out.println(<span class="string">"Just created weak: "</span> + weakList.getLast()+<span class="string">" Reference: "</span>+veryBigWeakReference.get());</span><br><span class="line">o = veryBigWeakReference.get();<span class="comment">// 把weak 改成strong 最后这个没有被回收</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.gc(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 下面休息几分钟，让上面的垃圾回收线程运行完成</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkQueue();</span><br><span class="line">System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recycleWeakTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt; weakList = <span class="keyword">new</span> LinkedList&lt;WeakReference&lt;VeryBig&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">VeryBigWeakReference veryBigWeakReference = <span class="keyword">new</span> VeryBigWeakReference(<span class="keyword">new</span> VeryBig(<span class="string">"Weak "</span> + i), rq);</span><br><span class="line">weakList.add(veryBigWeakReference);</span><br><span class="line">System.out.println(<span class="string">"Just created weak: "</span> + weakList.getLast()+<span class="string">" Reference: "</span>+veryBigWeakReference.get());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.gc(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 下面休息几分钟，让上面的垃圾回收线程运行完成</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recycleSoftTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">3</span>;</span><br><span class="line">LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt; weakList = <span class="keyword">new</span> LinkedList&lt;SoftReference&lt;VeryBig&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">VeryBigSoftReference veryBigSoftReference = <span class="keyword">new</span> VeryBigSoftReference(<span class="keyword">new</span> VeryBig(<span class="string">"Weak "</span> + i), rq);</span><br><span class="line">weakList.add(veryBigSoftReference);</span><br><span class="line">System.out.println(<span class="string">"Just created weak: "</span> + weakList.getLast()+<span class="string">" Reference: "</span>+veryBigSoftReference.get());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">System.gc(); </span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 下面休息几分钟，让上面的垃圾回收线程运行完成</span></span><br><span class="line">Thread.currentThread().sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkQueue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">changeWeakToStrong();<span class="comment">// 弱引用转化成强引用躲过一劫</span></span><br><span class="line"><span class="comment">// recycleWeakTest(); //触发垃圾回收，被扫描到立马会被回收</span></span><br><span class="line"><span class="comment">// recycleSoftTest();// 只有堆内存不够时才会被回收</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBig</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String id;</span><br><span class="line"><span class="comment">// 占用空间,让线程进行回收</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * <span class="number">1024</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VeryBig</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Finalizing VeryBig "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBigWeakReference</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">VeryBig</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VeryBigWeakReference</span><span class="params">(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(big, rq);</span><br><span class="line"><span class="keyword">this</span>.id = big.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeryBigSoftReference</span> <span class="keyword">extends</span> <span class="title">SoftReference</span>&lt;<span class="title">VeryBig</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String id;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">VeryBigSoftReference</span><span class="params">(VeryBig big, ReferenceQueue&lt;VeryBig&gt; rq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(big, rq);</span><br><span class="line"><span class="keyword">this</span>.id = big.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strongReferenceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            </span><br><span class="line">            map.put(<span class="keyword">new</span> <span class="keyword">byte</span>[_1M], value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map.size-&gt;"</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">weakReferenceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                WeakReference&lt;<span class="keyword">byte</span>[]&gt; k;</span><br><span class="line">                <span class="keyword">while</span>((k = (WeakReference) rq.remove()) != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">"回收了:"</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            WeakReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;<span class="keyword">byte</span>[]&gt;(bytes, rq);</span><br><span class="line">            map.put(weakReference, value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map.size-&gt;"</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">softReferenceTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                SoftReference&lt;<span class="keyword">byte</span>[]&gt; k;</span><br><span class="line">                <span class="keyword">while</span>((k = (SoftReference) rq.remove()) != <span class="keyword">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">"回收了:"</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; softReference = <span class="keyword">new</span> SoftReference&lt;<span class="keyword">byte</span>[]&gt;(bytes, rq);</span><br><span class="line">            map.put(softReference, value);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"map.size-&gt;"</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// strongReferenceTest(); //out of mermory</span></span><br><span class="line">        <span class="comment">// softReferenceTest(); // 堆内存不够时会回收</span></span><br><span class="line">        weakReferenceTest();<span class="comment">// 垃圾回收扫描到立马会被回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。&lt;/p&gt;
&lt;p&gt;1 强引用&lt;/p&gt;
&lt;p&gt;特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创
      
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载过程</title>
    <link href="http://shiyangtao.github.io/2017/07/28/jvm-2017-07-28-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://shiyangtao.github.io/2017/07/28/jvm-2017-07-28-类加载过程/</id>
    <published>2017-07-27T16:00:00.000Z</published>
    <updated>2019-01-25T09:08:36.685Z</updated>
    
    <content type="html"><![CDATA[<p>接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。</p><p><img src="https://upload-images.jianshu.io/upload_images/2455482-cc05b1b6e6b41f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p><ul><li>##加载<br>加载(loading) 是类加载(class loading)的一个过程,不要混淆。<br>加载分三步:</li></ul><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流<br>并没有指明二进制字节流要从class文件里获取可以是其他方式</li></ol><ul><li>从ZIP包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li><li>从网络中获取，这种场景最典型的应用就是Applet。</li><li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为”*$Proxy”的代理类的二进制字节流。</li><li>由其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。从数据库中读取，这种场景相对少见些，例如有些中间件服务器（如SAPNetweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。<br>…….</li></ul><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。</p><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><ul><li>##验证</li></ul><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>Java语言本身是相对安全的语言（依然是相对于C/C++来说），使用纯粹的Java代码无法做到诸如访问数组边界以外的数据、将一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果这样做了，编译器将拒绝编译。但前面已经说过，Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生Class文件。在字节码语言层面上，上述Java代码无法做到的事情都是可以实现的，至少语义上是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。<br>分为以下几步</p><ol><li>文件格式验证<br>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</li></ol><ul><li>是否以魔数0xCAFEBABE开头。</li><li>主、次版本号是否在当前虚拟机处理范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。<br>…<br>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li></ul><ol start="2"><li>元数据验证<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点如下：</li></ol><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。<br>……<br>第二阶段的主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。</li></ul><ol start="3"><li>字节码验证<br>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</li></ol><ul><li>在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。<br>……<br>如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。即使字节码验证之中进行了大量的检查，也不能保证这一点。</li></ul><ol start="4"><li>符号引用验证<br>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验下列内容：</li></ol><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li><p>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。<br>……<br>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，那么将会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p></li><li><p>##准备<br>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的概念需要强调一下，首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value=123；</span><br></pre></td></tr></table></figure></li></ul><p>那变量value在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器＜clinit＞()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。</p><p>上面提到，在“通常情况”下初始值是零值，那相对的会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，假设上面类变量value的定义变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int value=123；</span><br></pre></td></tr></table></figure></p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><ul><li>##解析<br>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</li></ul><p>符号引用（SymbolicReferences）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。</p><p>直接引用（DirectReferences）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</p><p>虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray(创建一个引用类型的数组)、checkcast(检验类型转换，校验未通过抛出ClassCastException)、getfield(获得指定类型的实例域)、getstatic(获得指定类型的静态域)、instanceof(检查对象是否是指定类的实例)、invokedynamic(调用动态链接方法)、invokeinterface(调用接口方法)、invokespecial(调用超类构造方法)、invokestatic(调用静态方法)、invokevirtual(调用实例方法)、ldc、ldc_w、multianewarray(创建指定类型的多维度数组)、new、putfield(为指定的类的实例域赋值)和putstatic(为指定的类的静态域赋值)这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>对同一个符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量类型，下面将讲解前4种类型的解析过程</p><ul><li>类或接口的解析<br>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要以下3个步骤：<br>1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。<br>2）如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似”[Ljava/lang/Integer”的形式，那将会按照第1点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是”java.lang.Integer”，接着由虚拟机生成一个代表此数组维度和元素的数组对象。<br>3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。</li><li>字段解析<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索。<br>1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>2）否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>3）否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。<br>4）否则，查找失败，抛出java.lang.NoSuchFieldError异常。<br>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。</li><li>类方法解析<br>类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。<br>1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。<br>2）如果通过了第1步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。<br>5）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。</li><li><p>接口方法解析<br>接口方法也需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索。<br>1）与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。<br>2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>3）否则，在接口C的父接口中递归查找，直到java.lang.Object类（查找范围会包括Object类）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。<br>4）否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。<br>由于接口中的所有方法默认都是public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出java.lang.IllegalAccessError异常。</p></li><li><p>##初始化<br>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。<br>对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”<a href="https://www.jianshu.com/p/98925f324eef" target="_blank" rel="noopener">参考</a></p></li></ul><p>在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞()方法的过程。我们在下文会讲解＜clinit＞()方法是怎么生成的，在这里，我们先看一下＜clinit＞()方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对更贴近于普通的程序开发人员。</p><p>＜clinit＞()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码清单中的例子所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">       i = 0;//给变量赋值可以编译通过</span><br><span class="line">       System.out.println(i);//编译器提示非法的向前引用</span><br><span class="line">   &#125;</span><br><span class="line">static int i = 1;</span><br></pre></td></tr></table></figure></p><p>＜clinit＞()方法与类的构造函数（或者说实例构造器＜init＞()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞()方法执行之前，父类的＜clinit＞()方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。</p><p>由于父类的＜clinit＞()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如在代码清单中，字段B的值将会是2而不是1。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       System.out.println(Sub.B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>＜clinit＞()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞()方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接下来我们详细讲解一下Java虚拟机中类加载的全过程，也就是加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2455482-cc05b1b6e6b41f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>类加载时机</title>
    <link href="http://shiyangtao.github.io/2017/05/04/jvm-2017-05-04-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/"/>
    <id>http://shiyangtao.github.io/2017/05/04/jvm-2017-05-04-类加载时机/</id>
    <published>2017-05-03T16:00:00.000Z</published>
    <updated>2019-01-25T09:08:32.525Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2455482-cc05b1b6e6b41f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a><br><strong>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。</strong><br>加载什么情况下需要开始类加载过程的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。<br>  对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ul><li>1）遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段<strong>（被final修饰、已在编译期把结果放入常量池的静态字段除外（看实例三））</strong>的时候，以及调用一个类的静态方法的时候。</li><li><p>2）使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p><ul><li>3）当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li><li><p>5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</p><p><strong>除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</strong><br><img src="https://upload-images.jianshu.io/upload_images/2455482-f72f85ed4ba6812b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">上述代码运行之后，只会输出”SuperClassinit！”，而不会输出”SubClassinit！”。<br>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p></li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2455482-afe18a4c21c34738.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">运行之后发现没有输出”SuperClassinit！”，说明并没有触发类org.fenixsoft.classloading.SuperClass的初始化阶段。但是这段代码里面触发了另外一个名为”[Lorg.fenixsoft.classloading.SuperClass”的类的初始化阶段，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于java.lang.Object的子类，创建动作由字节码指令newarray触发。这个类代表了一个元素类型为org.fenixsoft.classloading.SuperClass的一维数组，数组中应有的属性和方法（用户可直接使用的只有被修饰为public的length属性和clone()方法）都实现在这个类里。<br><img src="https://upload-images.jianshu.io/upload_images/2455482-cab9dcbd0de9ce57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>上述代码运行之后，也没有输出”ConstClassinit！”，这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但被<strong>final</strong>修饰在编译阶段通过常量传播优化，已经将此常量的值”helloworld”存储到了NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用了。</p><p>接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2455482-cc05b1b6e6b41f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>内存分配与回收策略</title>
    <link href="http://shiyangtao.github.io/2017/04/03/jvm-2017-04-03-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
    <id>http://shiyangtao.github.io/2017/04/03/jvm-2017-04-03-内存分配与回收策略/</id>
    <published>2017-04-02T16:00:00.000Z</published>
    <updated>2019-01-25T09:08:28.496Z</updated>
    
    <content type="html"><![CDATA[<p>Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：<strong>给对象分配内存以及回收分配给对象的内存。</strong><br>对象主要分配在堆上的Eden，如果启用的TLAB，那优先在TLAB上分配，少数情况会直接分配到老年代中，<strong>分配的规则不会100%确定的，取决于使用什么垃圾收集器，还有虚拟机相关参数设置</strong><br>接下来我们在Serial／Serial Old收集器下验证几种规则<br><a id="more"></a></p><h1 id="1-对象优先在Eden中分配"><a href="#1-对象优先在Eden中分配" class="headerlink" title="1. 对象优先在Eden中分配"></a>1. 对象优先在Eden中分配</h1><p><img src="https://upload-images.jianshu.io/upload_images/2455482-c4cce4ff7fb28765.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>执行<br><code>javac Test.java</code><br><code>java -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC Test</code><br>结果<img src="https://upload-images.jianshu.io/upload_images/2455482-2b8fdb199d97c75e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>#####解析:<br><strong>-Xms20M、-Xmx20M、-Xmn10M</strong>这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。<strong>-XX:SurvivorRatio=8</strong>决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果也可以清晰地看到”edenspace8192K、fromspace1024K、tospace1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量），<strong>-XX:UseSerialGC</strong> 指定使用Serial收集器。</p><p>执行testAllocation()中分配allocation4对象的语句时会发生一次MinorGC，这次GC的结果是新生代6816KB变为279KB，而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生MinorGC。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p><p>这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）。通过GC日志可以证实这一点</p><h1 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h1><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制<br><img src="https://upload-images.jianshu.io/upload_images/2455482-854fd65d32ea5b4f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>javac Test.java</code><br><code>java -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC Test</code><br><img src="https://upload-images.jianshu.io/upload_images/2455482-009b4cb1743eaf18.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>java -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:PretenureSizeThreshold=3145728 Test</code><br><img src="https://upload-images.jianshu.io/upload_images/2455482-740ed68e5d9a330c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>第一次直接分配在了eden空间，第二次指定-XX:PretenureSizeThreshold参数为3MB（就是3145728，这个参数不能像-Xmx之类的参数一样直接写3MB），因此超过3MB的对象都会直接在老年代进行分配，所以第二次老年代内存占比40%。<br><strong>注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，ParallelScavenge收集器不认识这个参数，ParallelScavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</strong></p><h1 id="3-长期存活的对象进入老年代"><a href="#3-长期存活的对象进入老年代" class="headerlink" title="3. 长期存活的对象进入老年代"></a>3. 长期存活的对象进入老年代</h1><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。<br>读者可以试试分别以-XX:MaxTenuringThreshold=1和-XX:MaxTenuringThreshold=15两种设置来执行代码<br><img src="https://upload-images.jianshu.io/upload_images/2455482-8b0e0b218ae86d35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><code>javac Test.java</code><br><code>java -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:MaxTenuringThreshold=1 Test</code><br><img src="https://upload-images.jianshu.io/upload_images/2455482-c14ea8aafa7bf88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>java -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC -XX:MaxTenuringThreshold=15 Test</code><br><img src="https://upload-images.jianshu.io/upload_images/2455482-6dba8b9d9c39f703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此方法中的allocation1对象需要(1024/5)KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代已使用的内存GC后非常干净地变成0KB。而MaxTenuringThreshold=15时，第二次GC发生后，allocation1对象则还留在新生代Survivor空间，这时新生代仍然有482KB被占用。</p><h1 id="4-动态年龄判定"><a href="#4-动态年龄判定" class="headerlink" title="4. 动态年龄判定"></a>4. 动态年龄判定</h1><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h1 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h1><ul><li>JDK6Update24之前：<br><img src="https://upload-images.jianshu.io/upload_images/2455482-7181a4bcb8880a30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>下面解释一下“冒险”是冒了什么风险，前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行FullGC来让老年代腾出更多空间。取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次MinorGC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（HandlePromotionFailure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免FullGC过于频繁。</code></li><li>在JDK6Update24之后：<br><img src="https://upload-images.jianshu.io/upload_images/2455482-b4d1c89f9ee5b9bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p>HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行MinorGC，否则将进行FullGC。</p><h1 id="6-小节"><a href="#6-小节" class="headerlink" title="6. 小节"></a>6. 小节</h1><p>内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。</p><p><strong>日志里GC和FullGC概念：</strong><br>GC日志开头的”[GC”和”[FullGC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有”Full”，说明这次GC是发生了Stop-The-World的，新生代收集器ParNew的日志也会出现”[FullGC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示”[FullGC（System）”。</p><p><strong>多次提到的MinorGC和FullGC有什么不一样吗？：</strong></p><ul><li>新生代GC（MinorGC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快。</li><li>老年代GC（MajorGC/FullGC）：指发生在老年代的GC，出现了MajorGC，经常会伴随至少一次的MinorGC（但非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）。MajorGC的速度一般会比MinorGC慢10倍以上。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：&lt;strong&gt;给对象分配内存以及回收分配给对象的内存。&lt;/strong&gt;&lt;br&gt;对象主要分配在堆上的Eden，如果启用的TLAB，那优先在TLAB上分配，少数情况会直接分配到老年代中，&lt;strong&gt;分配的规则不会100%确定的，取决于使用什么垃圾收集器，还有虚拟机相关参数设置&lt;/strong&gt;&lt;br&gt;接下来我们在Serial／Serial Old收集器下验证几种规则&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="blog" scheme="http://shiyangtao.github.io/categories/blog/"/>
    
    
      <category term="jvm" scheme="http://shiyangtao.github.io/tags/jvm/"/>
    
  </entry>
  
</feed>
