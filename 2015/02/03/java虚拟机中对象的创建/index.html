<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>java虚拟机中对象的创建 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;emsp;&amp;emsp;我们了解虚拟机内存划分的人，都知道对象的内存分配几乎都是在堆上的，这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都会在堆上分配（但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些变化，擦扯远了，所以所有的对象实例都在堆上分配就不是那么绝对了） 下面说虚拟机中对象的创建几个步骤  类加载检查&amp;emsp;&amp;emsp;虚拟机遇">
<meta name="keywords" content="jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="java虚拟机中对象的创建">
<meta property="og:url" content="http://yoursite.com/2015/02/03/java虚拟机中对象的创建/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="&amp;emsp;&amp;emsp;我们了解虚拟机内存划分的人，都知道对象的内存分配几乎都是在堆上的，这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都会在堆上分配（但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些变化，擦扯远了，所以所有的对象实例都在堆上分配就不是那么绝对了） 下面说虚拟机中对象的创建几个步骤  类加载检查&amp;emsp;&amp;emsp;虚拟机遇">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-23T12:01:32.714Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java虚拟机中对象的创建">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;我们了解虚拟机内存划分的人，都知道对象的内存分配几乎都是在堆上的，这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都会在堆上分配（但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些变化，擦扯远了，所以所有的对象实例都在堆上分配就不是那么绝对了） 下面说虚拟机中对象的创建几个步骤  类加载检查&amp;emsp;&amp;emsp;虚拟机遇">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java虚拟机中对象的创建" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/03/java虚拟机中对象的创建/" class="article-date">
  <time datetime="2015-02-02T16:00:00.000Z" itemprop="datePublished">2015-02-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java虚拟机中对象的创建
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> &emsp;&emsp;我们了解虚拟机内存划分的人，都知道对象的内存分配几乎都是在堆上的，这一点在java虚拟机规范中的描述是：所有的对象实例以及数组都会在堆上分配（但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些变化，擦扯远了，所以所有的对象实例都在堆上分配就不是那么绝对了）</p>
<p>下面说虚拟机中对象的创建几个步骤</p>
<ol>
<li>类加载检查<br>&emsp;&emsp;虚拟机遇到new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被装载、解析和初始化过。如果没有那必须先执行相应的类的加载过程。</li>
<li>为对象分配内存<br>&emsp;&emsp;当类加载成功后，类的对象的大小是确定了的。对象内存的划分等同于在堆里划分出一块指定大小的内存。<br>&emsp;&emsp;假设内存是规整的，所有用过的内存放在一边，空闲的放在另一边，中间分界点有个指针，那分配内存就是把指针向空闲区域方向挪动一段于对象大小相等的长度，这种分配方式叫做“指针碰撞”(Bump the Pointer)。<br>&emsp;&emsp;如果内存不是规整的，那么就需要一个表来记录，记录哪些内存是占用的，哪些是空闲的，那分配内存就是在表里找到一块足够大的空间分配给对象实例，并更新这个表的记录，这种分配方式叫做“空闲列表”(Free List)。<br>&emsp;&emsp;选择哪种分配方式与堆是否规整决定，而java堆是否规整又和垃圾收集器是否有压缩整理功能决定。因此，在使用Serial、ParNew等带有Compact过程的收集器时，采用的分配方式是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，采用的是空闲列表。<br>&emsp;&emsp;除了如何划分内存之外还有一个是我们需要考虑的问题，因为java堆是线程共享的，那么多个线程同时操作堆上的内存就会有问题，比如正在给a对象分配内存还没来得及移动指针(或者是没有修改空闲列表的记录)，这时对象b使用原来的指针来分配内存，就会产生问题。解决这个问题有两种方式，一种是对分配内存的动作进行同步处理(实际上虚拟机采用CAS配上错误重试来保证分配内存的原子性)；另一种是采用线程间不共享的内存来分配，每个线程预先在java堆中分配一块内存，成为本地线程分配缓冲(Thread Local Allocation Buffer,TLAB )。哪个线程分配内存就在该线程的TLAB上分配，只有在TLAB用完需要分配新的TLAB时，才需要同步锁定。注：虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</li>
<li>内存初始化<br>&emsp;&emsp;内存分配完后，需要把将分配到的内存空间初始化为零值(不包换对象头)，如果使用TLAB这一过程也可以提前至TLAB分配时进行。这一步操作保证了对象实例字段在java代码中可以不赋初值就使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li>对象头必要设置<br>&emsp;&emsp;接下来虚拟机要对对象进行必要的设置，比如该对象是哪个类的实例、如何才能找到类的元数据信息、对象的hash码、对象的gc分代年龄等信息。这些信息均放在对象的对象头(Object Header)中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置</li>
</ol>
<p>总结<br>以上步骤完成后，从虚拟机的角度来看，一个新对象诞生了，但从java程序角度看，一切才刚刚开始——init方法还没有执行，所有字段的数据类型都是对应的零值。所以一般来说执行new指令后会接着执行init方法，把对象按照程序猿的意愿进行初始化，这样一个真正可以使用的对象才算完成。</p>
<p>下面的代码是HotPot虚拟机bytecodeInterpreter.cpp的代码片段<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">u2 index = Bytes::get_Java_u2(pc+<span class="number">1</span>);</span><br><span class="line">ConstantPool* constants = istate-&gt;method()-&gt;constants();</span><br><span class="line"><span class="comment">// 确保常量池中是已经解释的类</span></span><br><span class="line"><span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123;</span><br><span class="line">  <span class="comment">// Make sure klass is initialized and doesn't have a finalizer</span></span><br><span class="line">  <span class="comment">// 确保类已经初始化</span></span><br><span class="line">  Klass* entry = constants-&gt;slot_at(index).get_klass();</span><br><span class="line">  assert(entry-&gt;is_klass(), <span class="string">"Should be resolved klass"</span>);</span><br><span class="line">  Klass* k_entry = (Klass*) entry;</span><br><span class="line">  assert(k_entry-&gt;oop_is_instance(), <span class="string">"Should be InstanceKlass"</span>);</span><br><span class="line">  InstanceKlass* ik = (InstanceKlass*) k_entry;</span><br><span class="line">  <span class="comment">// 确保对象内存已经初始化</span></span><br><span class="line">  <span class="keyword">if</span> ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123;</span><br><span class="line">    <span class="comment">// 取对象长度</span></span><br><span class="line">    <span class="keyword">size_t</span> obj_size = ik-&gt;size_helper();</span><br><span class="line">    oop result = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// If the TLAB isn't pre-zeroed then we'll have to do it</span></span><br><span class="line">    <span class="comment">// 如果TLAB没有预先初始化那么need_zero为true后边会进行初始化</span></span><br><span class="line">    <span class="keyword">bool</span> need_zero = !ZeroTLAB;</span><br><span class="line">    <span class="comment">// 如果虚拟机启用TLAB，那么在TLAB中分配对象</span></span><br><span class="line">    <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">      result = (oop) THREAD-&gt;tlab().allocate(obj_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      need_zero = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// Try allocate in shared eden</span></span><br><span class="line">      <span class="comment">// 尝试在eden中分配对象</span></span><br><span class="line">retry:</span><br><span class="line">      HeapWord* compare_to = *Universe::heap()-&gt;top_addr();</span><br><span class="line">      HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">      <span class="comment">/*cmpxchg是x86中的CAS指令，这里是一个C++方法通过CAS方式分配空间，如果并发失败，转到retry中重试直至成功分配为止*/</span></span><br><span class="line">      <span class="keyword">if</span> (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123;</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        result = (oop) compare_to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">// Initialize object (if nonzero size and need) and then the header</span></span><br><span class="line">     <span class="comment">// 如果需要，则为对象初始化零值</span></span><br><span class="line">      <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">        HeapWord* to_zero = (HeapWord*) result + <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">        obj_size -= <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">        <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">          <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据是否启用偏向锁来设置对象头信息</span></span><br><span class="line">      <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">        result-&gt;set_mark(ik-&gt;prototype_header());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;set_mark(markOopDesc::prototype());</span><br><span class="line">      &#125;</span><br><span class="line">      result-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">      result-&gt;set_klass(k_entry);</span><br><span class="line">     <span class="comment">// 将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">      SET_STACK_OBJECT(result, <span class="number">0</span>);</span><br><span class="line">      UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相关文章：<br><a href="https://www.jianshu.com/p/282777946dad" target="_blank" rel="noopener">java虚拟机中对象的创建</a><br><a href="https://www.jianshu.com/p/cc3f193db928" target="_blank" rel="noopener">java虚拟机中对象的内存布局</a><br><a href="https://www.jianshu.com/p/762f97391cac" target="_blank" rel="noopener">java虚拟机中对象的定位</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/03/java虚拟机中对象的创建/" data-id="cjr95435k0000gfwwa64r4aba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/04/03/java虚拟机中对象的内存布局/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java虚拟机中对象的内存布局
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/jvm/" style="font-size: 20px;">jvm</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/23/hello/">hello</a>
          </li>
        
          <li>
            <a href="/2019/01/23/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/03/24/运行时栈帧结构/">运行时栈帧结构</a>
          </li>
        
          <li>
            <a href="/2017/09/21/类加载器/">类加载器</a>
          </li>
        
          <li>
            <a href="/2017/07/28/类加载过程/">类加载过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>